
<!DOCTYPE html>
<html lang="en">


<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Raul Jordan | Custom Static Analysis in Go, Part I</title>
	<script defer src="https://use.fontawesome.com/releases/v5.8.1/js/all.js"
		integrity="sha384-g5uSoOSBd7KkhAMlnQILrecXvzst9TdC09/VM+pjDTCM+1il8RHz5fKANTFFb+gQ"
		crossorigin="anonymous"></script>
	<meta property="og:title" content="Custom Static Analysis in Go, Part I" />
	<meta name="author" content="Raul Jordan" />
	<meta property="og:locale" content="en_US" />
	<meta name="description" content="" />
	<meta property="og:description" content="" />
	<meta property="og:site_name" content="rauljordan" />
	<meta property="og:image" content="" />
	<meta property="og:type" content="article" />
	<meta property="article:published_time" content="2020-11-01T00:00:00&#43;0000" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="twitter:image" content="" />
	<meta property="twitter:title" content="Custom Static Analysis in Go, Part I" />
	<meta name="twitter:site" content="" />
	<meta name="twitter:creator" content="" />
	
	<link rel="stylesheet" href="/css/style.css">
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53062950-12"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() {dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-53062950-12');
	</script>
</head>


<body>
	
<div class="site-header">
	<div class="wrapper">
		<a class="site-title" rel="author" href="/">
			rauljordan
			<b class="command_prompt"></b><b class="blinking_cursor">_</b>
		</a>
		<span class="social_links">
			
			<a class="color-purple-hover" href="https://github.com/rauljordan"><i class="fab fa-github-square"></i></a>
			
			<a class="color-cyan-hover" href="https://twitter.com/rauljordaneth"><i class="fab fa-twitter-square"></i></a>
			
			<a class="color-red-hover" href="https://medium.com/@rauljordan"><i class="fab fa-medium"></i></a>
			
		</span>
	</div>
</div>

	<main class="page-content" aria-label="Content">
		<div class="wrapper">
			
<div class="author-box">
	<div class="flex-header">
		<div class="flex-img">
			<img src="https://gravatar.com/avatar/bbc15eb70de907e278d669fa0c1016fc?s=256" class="author-avatar" />
		</div>
		<div class="flex-content">
			Hi, my name is Raul Jordan - I am a software engineer working on the Ethereum blockchain protocol. I write about distributed systems programming, technology, life, and ideas for how we can create a less zero-sum world.
		</div>
	</div>

	<div class="read-more">
		Read more <a href="2017-01-01-about-me.html">about me</a> or contact me <a
			href="mailto:rauljordan@alumni.harvard.edu">rauljordan@alumni.harvard.edu</a>
	</div>
</div>

			
<div class="post">
	<h1 class="post-title">Custom Static Analysis in Go, Part I</h1>
	<div class="post-tags">
		
		<a class="tag" href="/tag/golang">golang</a>
		
	</div>
	<div class="post-date">Published on 24/01/2020</div>
	<div class="post-description"></div>
	<p><img src="https://www.scylladb.com/wp-content/uploads/1200x628-fb-golang-scylla-gocqlx-package.png" alt="Image"></p>
<p>(Credits to ScyllaDB)</p>
<p>Static analysis is the practice of examining source code in an automated way before code is run, typically to find bugs before they can even manifest. As a powerful programming language used in mission critical applications, <a href="https://golang.org/">Go</a> also adds a lot of responsibility to its developers to write safe code. The risk of nil pointer panics, variable shadowing, and otherwise ignoring important errors can make an otherwise good looking program become an easy target for attacks or faults you never imagined could happen.</p>
<h2>How this is different from using linters</h2>
<p>Linters, by definition, are already a type of static analyzers geared towards finding bad practices in your code among a set of accepted standards. Although linters provide a way to standardize your code according to a series of rules, there are some advanced edge cases that even linters cannot enforce, such as bugs which are specific to your application. For such edge cases, <strong>writing your own</strong> static analysis is your best bet.</p>
<p>By writing a static analysis tool, you can programmatically look through <em>your own source code</em> and enforce any rules you wish! In fact, Go makes static analysis very easy thanks to the golang.org/x/tools/go/analysis written by the Go team, giving us a ton of flexibility in terms of what we can do. We'll be using the standard library's analysis tools to look at important ways we can prevent our code from compiling with unsafe practices. The code for this blog post is available here on Github <a href="https://github.com/rauljordan/static-analysis">github.com/rauljordan/static-analysis</a>.</p>
<p>Let's first look at some prime examples of code which would benefit from static analysis, and are already caught by most major linters and tools such as <code>go vet</code>.</p>
<h3>Checking places in our code where we are not handling returned errors</h3>
<p>Sometimes we forget to properly handle or propagate errors in our Go code:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span>users, _ := db.<span style="color:#41a1c0">GetUsers</span>()
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">for</span> _, user := <span style="color:#fc5fa3">range</span> users {
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#41a1c0">Println</span>(user.Name)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>We aren't handling the error above, and if <code>users</code> is nil due to an error from a call to <code>db.GetUsers()</code>, we'll have a nil pointer panic in the code above at runtime. This is a common candidate for static analysis, and is actually already a popular one included in the <code>go vet</code> tool known as <code>errcheck</code>.</p>
<h3>Accidental variable shadowing</h3>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">test</span> () (x <span style="color:#fc5fa3">int64</span>, y <span style="color:#fc5fa3">int64</span>) {
</span></span><span style="display:flex;"><span>	x = <span style="color:#d0bf69">3</span>
</span></span><span style="display:flex;"><span>	y = <span style="color:#d0bf69">6</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">var</span> x <span style="color:#fc5fa3">int64</span> = <span style="color:#d0bf69">2</span>
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#41a1c0">Printf</span>(<span style="color:#fc6a5d">&#34;x %v \n&#34;</span>, x)
</span></span><span style="display:flex;"><span>	x, y := <span style="color:#41a1c0">test</span>()
</span></span><span style="display:flex;"><span> 	fmt.<span style="color:#41a1c0">Printf</span>(<span style="color:#fc6a5d">&#34;x %v y %v \n&#34;</span>, x, y)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Output</p>
<pre><code>x 2 
x 3 y 6 
</code></pre>
<p>Even though we initialized a new variable <code>y</code>, there was no new <code>x</code> variable declared, but rather the original value was <em>shadowed</em>, which is a big bug risk and source of many problems in Go codebases. Checking for accidental variable shadowing is another common use case for static analysis.</p>
<h2>Our use case: enforcing file permission best practices in our application</h2>
<p>At my company, we maintain an open source project called <a href="github.com/prysmaticlabs/prysm">Prysm</a> written in Go which is built to handle hundreds of millions of dollars, making it a prime target for attackers to steal from less tech savvy users, or users which may have unsafe configurations. In our particular application, we are writing sensitive files to a directory owned by the user. For this, we want to leverage unix file permissions to ensure any files only have read/write access from the user, and not from the group nor from other users on the same system.</p>
<p>What we want to accomplish for our application is ensure we have read/write access to files for the <em>current user</em> only. As a sanity check, we can use the following useful tool <a href="http://permissions-calculator.org/">permissions-calculator</a>:</p>
<p><img src="https://i.imgur.com/qvqSsVn.png" alt="Image"></p>
<p>UNIX Permissions use Octal notation, which you can read more about <a href="https://doane-ccla.gitbook.io/docs/learning-linux/file-permissions">here</a>. Based on the results of the calculator, permissions 0600 will accomplish our desired end-goal.</p>
<h3>Major problem: the standard library makes dangerous assumptions</h3>
<p>The Go standard library is great and packed with features. However, some of its useful ones such as <code>os.MkdirAll</code> and <code>ioutil.WriteFile</code> are dangerous if misused. Say we want to create a directory, such as <code>myapplication/secrets/</code>, we can write the following code to aid us:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Write with user only read/write/execute permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">MkdirAll</span>(<span style="color:#fc6a5d">&#34;myapplication/secrets&#34;</span>, <span style="color:#d0bf69">0700</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write directory: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>However, turns out the code above will complete <em>without error</em> if the directory already exists, <strong>even if it has different permissions</strong>. Let's write a test:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">TestMkdirAll_SilentFailure</span>(t *testing.T) {
</span></span><span style="display:flex;"><span>	dirPath := <span style="color:#fc6a5d">&#34;myapplication/secrets&#34;</span>
</span></span><span style="display:flex;"><span>	t.<span style="color:#41a1c0">Cleanup</span>(<span style="color:#fc5fa3">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">RemoveAll</span>(dirPath); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>			t.<span style="color:#41a1c0">Error</span>(<span style="color:#fc6a5d">&#34;Could not remove directory&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Evil attacker creates the directory ahead of time
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#6c7986">// with full 777 permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">MkdirAll</span>(dirPath, <span style="color:#d0bf69">0777</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write directory: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Now our application attempts to write to the directory
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#6c7986">// with 700 permissions to only allow current user read/write/exec.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">MkdirAll</span>(dirPath, <span style="color:#d0bf69">0700</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write directory: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	info, err := os.<span style="color:#41a1c0">Stat</span>(dirPath)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Check if other users have read permission.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> info.<span style="color:#41a1c0">Mode</span>()&amp;(<span style="color:#d0bf69">1</span>&lt;&lt;<span style="color:#d0bf69">2</span>) != <span style="color:#d0bf69">0</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Error</span>(<span style="color:#fc6a5d">&#34;Expected permissions only for user&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Let's run the test</p>
<pre><code>$ go test .
--- FAIL: TestMkdirAll_SilentFailure (0.00s)
    main_test.go:61: Expected permissions only for user
FAIL
</code></pre>
<p>Yikes! No error here in the second call to <code>os.MkdirAll</code>, and even worse, the attacker was able to create a directory with the most open permissions possible, compromising the security assumptions of our application. What gives? For one, the standard library needs to make as few assumptions about desired default behavior, and turns out this assumption was the simplest they could make. Second, the same behavior is also found in the popular <code>ioutil</code> package's <code>WriteFile</code> function. Let's see:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;io/ioutil&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;path/filepath&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">TestWriteFile_SilentFailure</span>(t *testing.T) {
</span></span><span style="display:flex;"><span>	dirPath := <span style="color:#fc6a5d">&#34;myapplication/secrets&#34;</span>
</span></span><span style="display:flex;"><span>	t.<span style="color:#41a1c0">Cleanup</span>(<span style="color:#fc5fa3">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">RemoveAll</span>(dirPath); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>			t.<span style="color:#41a1c0">Error</span>(<span style="color:#fc6a5d">&#34;Could not remove directory&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// We create a directory with 777 permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> err := os.<span style="color:#41a1c0">MkdirAll</span>(dirPath, <span style="color:#d0bf69">0777</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write directory: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	secretFile := filepath.<span style="color:#41a1c0">Join</span>(dirPath, <span style="color:#fc6a5d">&#34;credentials.txt&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> err := ioutil.<span style="color:#41a1c0">WriteFile</span>(secretFile, []<span style="color:#d0a8ff">byte</span>(<span style="color:#fc6a5d">&#34;password&#34;</span>), <span style="color:#d0bf69">0777</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write file: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> err := ioutil.<span style="color:#41a1c0">WriteFile</span>(secretFile, []<span style="color:#d0a8ff">byte</span>(<span style="color:#fc6a5d">&#34;password&#34;</span>), <span style="color:#d0bf69">0600</span>); err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatalf</span>(<span style="color:#fc6a5d">&#34;Could not write file: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	info, err := os.<span style="color:#41a1c0">Stat</span>(secretFile)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> err != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Check if other users have read permission.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#fc5fa3">if</span> info.<span style="color:#41a1c0">Mode</span>()&amp;(<span style="color:#d0bf69">1</span>&lt;&lt;<span style="color:#d0bf69">2</span>) != <span style="color:#d0bf69">0</span> {
</span></span><span style="display:flex;"><span>		t.<span style="color:#41a1c0">Error</span>(<span style="color:#fc6a5d">&#34;Expected permissions only for user&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Let's run the test</p>
<pre><code>$ go test .
--- FAIL: TestWriteFile_SilentFailure (0.00s)
    main_test.go:61: Expected permissions only for user
FAIL
</code></pre>
<p>Same thing! We don't even get an error if we try to write to a file that was already compromised by an attacker with different permissions. It's clear these file writing utilities from the standard library are risky if you are writing a critical application, and we should instead use our own specific functions that properly check against this issue. For example, we can create our little package in our application called <code>fileutil</code>, where we create our own <code>WriteFile</code> and <code>MkdirAll</code>.</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> fileutil
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">WriteFile</span>(filename <span style="color:#fc5fa3">string</span>, data []<span style="color:#fc5fa3">byte</span>) <span style="color:#fc5fa3">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Make sure the file does not already exist with different permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Write a file with strict, 600 permissions (read/write for user only).
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">MkdirAll</span>(dir <span style="color:#fc5fa3">string</span>) <span style="color:#fc5fa3">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Make sure the directory does not already exist with different permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Write a directory with strict, 700 permissions (read/write/execute for user only).
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Great, now we can just tell every developer in the company or contributors to our open source project to <em>not</em> use <code>os</code> nor <code>ioutil</code> but instead our own <code>fileutil</code> package, right? With a rapidly moving codebase, especially in open source code, this becomes next to impossible. We should instead make that part of our continuous integration suite by adding it into an existing static check tool such as <a href="https://golang.org/cmd/vet/">go vet</a> for the project to build at all if using the standard library's file writing utilities. This is where static analysis happens, making sure our program errors out before it even runs.</p>
<h3>Approach: static analysis to ensure safe file and dir writing</h3>
<p>The goal or our static analyzer will be as follows:</p>
<ol>
<li>Check if we are importing the <code>os</code> or <code>io/ioutil</code> package normally or as an alias</li>
<li>Check if function calls in our program use <code>ioutil.WriteFile</code> or <code>os.MkdirAll</code>, and raise issues</li>
</ol>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#6c7986">// Package writefile implements a static analyzer to ensure that our project does not
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986">// use ioutil.MkdirAll or os.WriteFile as they are unsafe when it comes to guaranteeing
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986">// file permissions and not overriding existing permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">package</span> writefile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;go/ast&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis/passes/inspect&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/ast/inspector&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6c7986">// Doc explaining the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">const</span> Doc = <span style="color:#fc6a5d">&#34;Tool to enforce usage of our own internal file-writing utils instead of os.MkdirAll or ioutil.WriteFile&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">var</span> errUnsafePackage = errors.<span style="color:#41a1c0">New</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os and ioutil dir and file writing functions are not permissions-safe, use shared/fileutil&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6c7986">// Analyzer runs static analysis.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">var</span> Analyzer = &amp;analysis.Analyzer{
</span></span><span style="display:flex;"><span>	Name:     <span style="color:#fc6a5d">&#34;writefile&#34;</span>,
</span></span><span style="display:flex;"><span>	Doc:      Doc,
</span></span><span style="display:flex;"><span>	Requires: []*analysis.Analyzer{inspect.Analyzer},
</span></span><span style="display:flex;"><span>	Run:      run,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">run</span>(pass *analysis.Pass) (<span style="color:#fc5fa3">interface</span>{}, <span style="color:#fc5fa3">error</span>) {
</span></span></code></pre><p>Above, we define our imports, using the <code>golang.org/x/tools/go/analysis</code> package created by the language authors, and defining some important globals such as info about the analyzer and the error message we want to print out upon discovering the pattern searched for by the analyzer. To run the analyzer, we need a special syntax for our package, which will tell tools such as go vet how we should run this. Our package needs to expose an <code>Analyzer</code> struct, and a <code>run(pass *analysis.Pass) (interface{}, error)</code> function. Let's now use this to parse the AST (Abstract Syntax Tree) of our program.</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">run</span>(pass *analysis.Pass) (<span style="color:#fc5fa3">interface</span>{}, <span style="color:#fc5fa3">error</span>) {
</span></span><span style="display:flex;"><span>	inspect, ok := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> !ok {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">return</span> <span style="color:#fc5fa3">nil</span>, errors.<span style="color:#41a1c0">New</span>(<span style="color:#fc6a5d">&#34;analyzer is not type *inspector.Inspector&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nodeFilter := []ast.Node{
</span></span><span style="display:flex;"><span>		(*ast.File)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>		(*ast.ImportSpec)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>		(*ast.CallExpr)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	aliases := <span style="color:#d0a8ff">make</span>(<span style="color:#fc5fa3">map</span>[<span style="color:#fc5fa3">string</span>]<span style="color:#fc5fa3">string</span>)
</span></span><span style="display:flex;"><span>	disallowedFns := []<span style="color:#fc5fa3">string</span>{<span style="color:#fc6a5d">&#34;MkdirAll&#34;</span>, <span style="color:#fc6a5d">&#34;WriteFile&#34;</span>}
</span></span></code></pre><p>Using the <code>&quot;go/ast&quot;</code> package, we can tell our inspector to filter out certain Go keywords, function calls, or imports. In this case, we want to retrieve either new go file definitions, go imports, and call expressions (fancy name for function calls). Additionally, we keep track of a map of aliases for imports and the disallowed functions our linter is checking for <code>MkdirAll</code> and <code>WriteFile</code>.</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">run</span>(pass *analysis.Pass) (<span style="color:#fc5fa3">interface</span>{}, <span style="color:#fc5fa3">error</span>) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	inspect.<span style="color:#41a1c0">Preorder</span>(nodeFilter, <span style="color:#fc5fa3">func</span>(node ast.Node) {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">switch</span> stmt := node.(<span style="color:#fc5fa3">type</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.ImportSpec:
</span></span><span style="display:flex;"><span>			...
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.CallExpr:
</span></span><span style="display:flex;"><span>			...
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.File:
</span></span><span style="display:flex;"><span>			...
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">return</span> <span style="color:#fc5fa3">nil</span>, <span style="color:#fc5fa3">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Next up, we actualy inspect our program and filter out nodes in the AST using our defined filters via the <code>inspect.Preorder</code> function, which gives us the ability to switch over the node types based on the filters we defined.</p>
<p>First, if we see a Go import, we want to check if it is is &quot;os&quot; or &quot;io/ioutil&quot; and keep track of it by its defined name or just by their regular import name if aliased into an <code>aliases</code> map we defined.</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#6c7986">// Collect aliases.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>pkg := stmt.Path.Value
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">if</span> pkg == <span style="color:#fc6a5d">&#34;\&#34;os\&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> stmt.Name != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		aliases[stmt.Name.Name] = stmt.Path.Value
</span></span><span style="display:flex;"><span>	} <span style="color:#fc5fa3">else</span> {
</span></span><span style="display:flex;"><span>		aliases[<span style="color:#fc6a5d">&#34;os&#34;</span>] = stmt.Path.Value
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">if</span> pkg == <span style="color:#fc6a5d">&#34;\&#34;io/ioutil\&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> stmt.Name != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>		aliases[stmt.Name.Name] = stmt.Path.Value
</span></span><span style="display:flex;"><span>	} <span style="color:#fc5fa3">else</span> {
</span></span><span style="display:flex;"><span>		aliases[<span style="color:#fc6a5d">&#34;ioutil&#34;</span>] = stmt.Path.Value
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Next, if we see a call expression, which is just a function call, we check if it is part of the aliases map
and if it is one of our disallowed functions:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">for</span> pkg, path := <span style="color:#fc5fa3">range</span> aliases {
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">for</span> _, fn := <span style="color:#fc5fa3">range</span> disallowedFns {
</span></span><span style="display:flex;"><span>		<span style="color:#6c7986">// Check if it is a dot imported package.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>		<span style="color:#fc5fa3">if</span> <span style="color:#41a1c0">isPkgDot</span>(stmt.Fun, pkg, fn) {
</span></span><span style="display:flex;"><span>			pass.<span style="color:#41a1c0">Reportf</span>(
</span></span><span style="display:flex;"><span>				node.<span style="color:#41a1c0">Pos</span>(),
</span></span><span style="display:flex;"><span>				fmt.<span style="color:#41a1c0">Sprintf</span>(
</span></span><span style="display:flex;"><span>					<span style="color:#fc6a5d">&#34;%v: %s.%s() (from %s)&#34;</span>,
</span></span><span style="display:flex;"><span>					errUnsafePackage,
</span></span><span style="display:flex;"><span>					pkg,
</span></span><span style="display:flex;"><span>					fn,
</span></span><span style="display:flex;"><span>					path,
</span></span><span style="display:flex;"><span>				),
</span></span><span style="display:flex;"><span>			)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>If this is the case, then we report on the analysis with our package defined error variable, letting the user know they should not be using those functions but instead, our own <code>fileutil</code> package. Here's the final result:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#6c7986">// Package writefile implements a static analyzer to ensure our project does not
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986">// use ioutil.MkdirAll or os.WriteFile as they are unsafe when it comes to guaranteeing
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986">// file permissions and not overriding existing permissions.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">package</span> writefile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;go/ast&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis/passes/inspect&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/ast/inspector&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6c7986">// Doc explaining the tool.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">const</span> Doc = <span style="color:#fc6a5d">&#34;Tool to enforce usage of our own file-writing utils instead of os.MkdirAll or ioutil.WriteFile&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">var</span> errUnsafePackage = errors.<span style="color:#41a1c0">New</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os and ioutil dir and file writing functions are not permissions-safe, use shared/fileutil&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6c7986">// Analyzer runs static analysis.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span><span style="color:#fc5fa3">var</span> Analyzer = &amp;analysis.Analyzer{
</span></span><span style="display:flex;"><span>	Name:     <span style="color:#fc6a5d">&#34;writefile&#34;</span>,
</span></span><span style="display:flex;"><span>	Doc:      Doc,
</span></span><span style="display:flex;"><span>	Requires: []*analysis.Analyzer{inspect.Analyzer},
</span></span><span style="display:flex;"><span>	Run:      run,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">run</span>(pass *analysis.Pass) (<span style="color:#fc5fa3">interface</span>{}, <span style="color:#fc5fa3">error</span>) {
</span></span><span style="display:flex;"><span>	inspect, ok := pass.ResultOf[inspect.Analyzer].(*inspector.Inspector)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">if</span> !ok {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">return</span> <span style="color:#fc5fa3">nil</span>, errors.<span style="color:#41a1c0">New</span>(<span style="color:#fc6a5d">&#34;analyzer is not type *inspector.Inspector&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	nodeFilter := []ast.Node{
</span></span><span style="display:flex;"><span>		(*ast.File)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>		(*ast.ImportSpec)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>		(*ast.CallExpr)(<span style="color:#fc5fa3">nil</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	aliases := <span style="color:#d0a8ff">make</span>(<span style="color:#fc5fa3">map</span>[<span style="color:#fc5fa3">string</span>]<span style="color:#fc5fa3">string</span>)
</span></span><span style="display:flex;"><span>	disallowedFns := []<span style="color:#fc5fa3">string</span>{<span style="color:#fc6a5d">&#34;MkdirAll&#34;</span>, <span style="color:#fc6a5d">&#34;WriteFile&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inspect.<span style="color:#41a1c0">Preorder</span>(nodeFilter, <span style="color:#fc5fa3">func</span>(node ast.Node) {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">switch</span> stmt := node.(<span style="color:#fc5fa3">type</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.File:
</span></span><span style="display:flex;"><span>			<span style="color:#6c7986">// Reset aliases (per file).
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>			aliases = <span style="color:#d0a8ff">make</span>(<span style="color:#fc5fa3">map</span>[<span style="color:#fc5fa3">string</span>]<span style="color:#fc5fa3">string</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.ImportSpec:
</span></span><span style="display:flex;"><span>			<span style="color:#6c7986">// Collect aliases.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>			pkg := stmt.Path.Value
</span></span><span style="display:flex;"><span>			<span style="color:#fc5fa3">if</span> pkg == <span style="color:#fc6a5d">&#34;\&#34;os\&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#fc5fa3">if</span> stmt.Name != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>					aliases[stmt.Name.Name] = stmt.Path.Value
</span></span><span style="display:flex;"><span>				} <span style="color:#fc5fa3">else</span> {
</span></span><span style="display:flex;"><span>					aliases[<span style="color:#fc6a5d">&#34;os&#34;</span>] = stmt.Path.Value
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#fc5fa3">if</span> pkg == <span style="color:#fc6a5d">&#34;\&#34;io/ioutil\&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#fc5fa3">if</span> stmt.Name != <span style="color:#fc5fa3">nil</span> {
</span></span><span style="display:flex;"><span>					aliases[stmt.Name.Name] = stmt.Path.Value
</span></span><span style="display:flex;"><span>				} <span style="color:#fc5fa3">else</span> {
</span></span><span style="display:flex;"><span>					aliases[<span style="color:#fc6a5d">&#34;ioutil&#34;</span>] = stmt.Path.Value
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		<span style="color:#fc5fa3">case</span> *ast.CallExpr:
</span></span><span style="display:flex;"><span>			<span style="color:#6c7986">// Check if any of disallowed functions have been used.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>			<span style="color:#fc5fa3">for</span> pkg, path := <span style="color:#fc5fa3">range</span> aliases {
</span></span><span style="display:flex;"><span>				<span style="color:#fc5fa3">for</span> _, fn := <span style="color:#fc5fa3">range</span> disallowedFns {
</span></span><span style="display:flex;"><span>					<span style="color:#fc5fa3">if</span> <span style="color:#41a1c0">isPkgDot</span>(stmt.Fun, pkg, fn) {
</span></span><span style="display:flex;"><span>						pass.<span style="color:#41a1c0">Reportf</span>(
</span></span><span style="display:flex;"><span>							node.<span style="color:#41a1c0">Pos</span>(),
</span></span><span style="display:flex;"><span>							fmt.<span style="color:#41a1c0">Sprintf</span>(
</span></span><span style="display:flex;"><span>								<span style="color:#fc6a5d">&#34;%v: %s.%s() (from %s)&#34;</span>,
</span></span><span style="display:flex;"><span>								errUnsafePackage,
</span></span><span style="display:flex;"><span>								pkg,
</span></span><span style="display:flex;"><span>								fn,
</span></span><span style="display:flex;"><span>								path,
</span></span><span style="display:flex;"><span>							),
</span></span><span style="display:flex;"><span>						)
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">return</span> <span style="color:#fc5fa3">nil</span>, <span style="color:#fc5fa3">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">isPkgDot</span>(expr ast.Expr, pkg, name <span style="color:#fc5fa3">string</span>) <span style="color:#fc5fa3">bool</span> {
</span></span><span style="display:flex;"><span>	sel, ok := expr.(*ast.SelectorExpr)
</span></span><span style="display:flex;"><span>	res := ok &amp;&amp; <span style="color:#41a1c0">isIdent</span>(sel.X, pkg) &amp;&amp; <span style="color:#41a1c0">isIdent</span>(sel.Sel, name)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">isIdent</span>(expr ast.Expr, ident <span style="color:#fc5fa3">string</span>) <span style="color:#fc5fa3">bool</span> {
</span></span><span style="display:flex;"><span>	id, ok := expr.(*ast.Ident)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">return</span> ok &amp;&amp; id.Name == ident
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><h3>Tests for our analyzer</h3>
<p>Fortunately, the standard library contains a very easy way to test out your analyzer, but it also comes with a few quirks and a specific syntax needed to get it to work. First, let's define a <code>testdata/</code> directory within our analyzer package. Then, create an <code>analyzer_test.go</code> file:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> writefile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis/analysistest&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">TestAnalyzer</span>(t *testing.T) {
</span></span><span style="display:flex;"><span>	analysistest.<span style="color:#41a1c0">Run</span>(t, analysistest.<span style="color:#41a1c0">TestData</span>(), Analyzer)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>We can use the <code>analysistest</code> package to run a bunch of cases within a <code>testdata/</code> directory for the analyzer, which we'll look into next. At this point, our folder structure looks as follows:</p>
<pre><code>static-analysis/
	main.go
	writefile/
		analyzer.go
		analyzer_test.go
		testdata/
			imports.go
</code></pre>
<p>In terms of test data, these aren't typical Go test files, but instead follow a specific syntax you can read about <a href="https://godoc.org/golang.org/x/tools/go/analysis/analysistest">here</a>.</p>
<blockquote>
<p>An expectation of a Diagnostic is specified by a string literal containing a regular expression that must match the diagnostic message. For example:</p>
</blockquote>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span>fmt.<span style="color:#41a1c0">Printf</span>(<span style="color:#fc6a5d">&#34;%s&#34;</span>, <span style="color:#d0bf69">1</span>) <span style="color:#6c7986">// want `cannot provide int 1 to %s`
</span></span></span></code></pre><p>So your tests must be comprised of function calls or expressions, followed by a comment next to them expecting what error you want the analyzer to report. In our case, we can write a few examples:</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> testdata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;crypto/rand&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;io/ioutil&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;math/big&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;path/filepath&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">UseOsMkdirAllAndWriteFile</span>() {
</span></span><span style="display:flex;"><span>	randPath, _ := rand.<span style="color:#41a1c0">Int</span>(rand.Reader, big.<span style="color:#41a1c0">NewInt</span>(<span style="color:#d0bf69">1000000</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Create a random file path in our tmp dir.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	p := filepath.<span style="color:#41a1c0">Join</span>(os.<span style="color:#41a1c0">TempDir</span>(), fmt.<span style="color:#41a1c0">Sprintf</span>(<span style="color:#fc6a5d">&#34;/%d&#34;</span>, randPath))
</span></span><span style="display:flex;"><span>	_ = os.<span style="color:#41a1c0">MkdirAll</span>(p, os.ModePerm) <span style="color:#6c7986">// want &#34;os and ioutil dir and file writing functions are not permissions-safe, use shared/fileutil&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	someFile := filepath.<span style="color:#41a1c0">Join</span>(p, <span style="color:#fc6a5d">&#34;some.txt&#34;</span>)
</span></span><span style="display:flex;"><span>	_ = ioutil.<span style="color:#41a1c0">WriteFile</span>(someFile, []<span style="color:#d0a8ff">byte</span>(<span style="color:#fc6a5d">&#34;hello&#34;</span>), os.ModePerm) <span style="color:#6c7986">// want &#34;os and ioutil dir and file writing functions are not permissions-safe, use shared/fileutil&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>}
</span></span></code></pre><p>Next up, we can run go test to check if our analyzer indeed reports on those functions being used when they shouldn't:</p>
<pre><code>$ go test ./writefile
ok  	github.com/rauljordan/static-analysis/writefile	0.845s
</code></pre>
<h3>Applying the analyzer using Go vet</h3>
<p>To run our analyzer as a standalone command, the standard library also provides some utility. All we have to do is define the following main.go file</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;github.com/rauljordan/static-analysis/writefile&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#fc6a5d">&#34;golang.org/x/tools/go/analysis/singlechecker&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">main</span>() {
</span></span><span style="display:flex;"><span>	singlechecker.<span style="color:#41a1c0">Main</span>(writefile.Analyzer)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Then, you can install it into your system $GOBIN with:</p>
<pre><code>go install github.com/rauljordan/static-analysis
</code></pre>
<p>Next, you can run it as a standalone Go binary passing in a path to a Go package you want to analyze:</p>
<pre><code>static-analysis ./mybadpackage
</code></pre>
<p>and see the analyzer in action. You can also integrate it into go vet with <code>go vet -vettool=$(which static-analysis) ./mybadpackage</code> as a custom analyzer. The code for this blog post is available here on Github <a href="https://github.com/rauljordan/static-analysis">github.com/rauljordan/static-analysis</a>.</p>
<h2>Next post: advanced static analysis for Go channels</h2>
<p>Although parsing the basic AST of a program as well as comparing identifiers to some string are easy operations, the high-level analysis package does not offer much tooling to dive in deeper into actually <em>understanding</em> a program. Let's say we want to prevent our Go code from ever sending over an unbuffered channel where there is no receiver ready. For those unfamiliar, the following Go program will block the main thread of the function we care about, which is not the expected behavior at runtime.</p>
<pre tabindex="0" style="color:#fff;background-color:#1f1f24;"><code><span style="display:flex;"><span><span style="color:#fc5fa3">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">type</span> Email <span style="color:#fc5fa3">struct</span> {
</span></span><span style="display:flex;"><span>	Subject <span style="color:#fc5fa3">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">main</span>() {
</span></span><span style="display:flex;"><span>	ch := <span style="color:#d0a8ff">make</span>(<span style="color:#fc5fa3">chan</span> *Email)
</span></span><span style="display:flex;"><span>	<span style="color:#fc5fa3">defer</span> <span style="color:#d0a8ff">close</span>(ch)
</span></span><span style="display:flex;"><span>	<span style="color:#41a1c0">handleEmailSignup</span>(ch)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fc5fa3">func</span> <span style="color:#41a1c0">handleEmailSignup</span>(ch <span style="color:#fc5fa3">chan</span> *Email) {
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Some logic regarding handling a signup event.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// We send over the channel, which we deliberately did not prepare
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	<span style="color:#6c7986">// a receiver for in another function, thereby blocking the thread.
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	ch &lt;- &amp;Email{
</span></span><span style="display:flex;"><span>		Subject: <span style="color:#fc6a5d">&#34;New user signup&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6c7986">// Warning: we&#39;ll never hit this line if there is no channel receiver!
</span></span></span><span style="display:flex;"><span><span style="color:#6c7986"></span>	log.<span style="color:#41a1c0">Println</span>(<span style="color:#fc6a5d">&#34;New user has just signed up!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Because there is no channel receiver set up, we'll never reach the log <code>New user has just signed up</code>, and we will actually block the main thread. This is very dangerous in production applications, where they may not be a channel receiver ready in time before we attempt sending over the channel.</p>
<p>To enforce this invariant via static analysis seems daunting, as we not only need to understand where channel operations are called, but also understand whether or not (a) the channel is unbuffered, and (b) we are writing to the same channel pointer in different parts of our program, perhaps in different packages! In a future blog post, we'll look at some advanced tools available in the Go standard library for deeper static analysis. Thanks for reading!</p>

</div>

<div class="comments">
	
<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
		this.page.url = 'https://rauljordan.com/\/2020\/11\/01\/custom-static-analysis-in-go-part-1.html';
		this.page.identifier = '\/2020\/11\/01\/custom-static-analysis-in-go-part-1.html';
		this.page.title = 'Custom Static Analysis in Go, Part I';
	};

	(function () {
		var d = document, s = d.createElement('script');

		s.src = '//rauljordanblog-1.disqus.com/embed.js';

		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
		powered by Disqus.</a></noscript>

</div>

		</div>
	</main>
	
<footer class="site-footer">
	<div class="wrapper">
		<div class="credits">Made With Golang <i class="fas fa-heart"></i></div>
	</div>
</footer>

	<script>
		window.FontAwesomeConfig = {
			searchPseudoElements: true
		}
	</script>
</body>

</html>
