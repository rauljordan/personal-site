
<!DOCTYPE html>
<html lang="en">


<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Raul Jordan | Blog Series: Pure, functional programming for modern blockchain development</title>
	<script defer src="https://use.fontawesome.com/releases/v5.8.1/js/all.js"
		integrity="sha384-g5uSoOSBd7KkhAMlnQILrecXvzst9TdC09/VM+pjDTCM+1il8RHz5fKANTFFb+gQ"
		crossorigin="anonymous"></script>
	<meta property="og:title" content="Blog Series: Pure, functional programming for modern blockchain development" />
	<meta name="author" content="Raul Jordan" />
	<meta property="og:locale" content="en_US" />
	<meta name="description" content="" />
	<meta property="og:description" content="" />
	<meta property="og:site_name" content="rauljordan" />
	<meta property="og:image" content="" />
	<meta property="og:type" content="article" />
	<meta property="article:published_time" content="2022-09-25T00:00:00&#43;0000" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="twitter:image" content="" />
	<meta property="twitter:title" content="Blog Series: Pure, functional programming for modern blockchain development" />
	<meta name="twitter:site" content="" />
	<meta name="twitter:creator" content="" />
	
	<link rel="stylesheet" href="/css/style.css">
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-53062950-12"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() {dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-53062950-12');
	</script>
</head>


<body>
	
<div class="site-header">
	<div class="wrapper">
		<a class="site-title" rel="author" href="/">
			rauljordan
			<b class="command_prompt"></b><b class="blinking_cursor">_</b>
		</a>
		<span class="social_links">
			
			<a class="color-purple-hover" href="https://github.com/rauljordan"><i class="fab fa-github-square"></i></a>
			
			<a class="color-cyan-hover" href="https://twitter.com/rauljordaneth"><i class="fab fa-twitter-square"></i></a>
			
			<a class="color-red-hover" href="https://medium.com/@rauljordan"><i class="fab fa-medium"></i></a>
			
		</span>
	</div>
</div>

	<main class="page-content" aria-label="Content">
		<div class="wrapper">
			
<div class="author-box">
	<div class="flex-header">
		<div class="flex-img">
			<img src="https://gravatar.com/avatar/bbc15eb70de907e278d669fa0c1016fc?s=256" class="author-avatar" />
		</div>
		<div class="flex-content">
			Hi, my name is Raul Jordan. I am a Go software engineer working on the Ethereum blockchain protocol. I write about distributed systems programming, technology, life, and ideas for how we can create a less zero-sum world.
		</div>
	</div>

	<div class="read-more">
		Read more <a href="/2017/01/01/about-me.html">about me</a> or contact me <a
			href="mailto:rauljordan@alumni.harvard.edu">rauljordan@alumni.harvard.edu</a>
	</div>
</div>

			
<div class="post">
	<h1 class="post-title">Blog Series: Pure, functional programming for modern blockchain development</h1>
	<div class="post-tags">
		
		<a class="tag" href="/tag/functional-programming">functional-programming</a>
		
	</div>
	<div class="post-date">Published on 24/01/2020</div>
	<p>Today, modern blockchains tend to be built in the popular Rust and Go programming languages for the
myriad benefits they offer. In particular, Rust has risen to popularity with empowering developers to write
memory-safe software and great performance while Go has been a complentary choice for its powerful concurrency
and networking primitives while being easy to write. In domain of distributed systems engineering, writing
software that is less bug-prone, more secure, and performant are what we tend to optimize for.</p>
<p>This blog series will focus on making the case for functional programming as a fantastic approach to blockchain development.
Each post will assume little-to-no familiarity with functional programming concepts, and focus on
showing how it can be used to solve <em>real problems</em>. We will not go into any mathematical topics and instead
only showcase how these concepts are useful by example.</p>
<p>In each post, we'll introduce different concepts of functional programming and solve problems
we run into when designing distributed systems. We'll be using the Haskell programming language in this series and will be introducing
language constructs as we go along. No need to be a Haskell expert to understand the premise of each post.
The series will culminate with guidance on how to develop software for production using a modern Haskell stack that actually works!</p>
<h2>What exactly is functional programming?</h2>
<p>The most popular, modern languages today use imperative programming, which works as a series of defined procedures
to accomplish a task. In Go, for example, the <code>main()</code> function of your program can do anything as an ordered procedure of computation.</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>  db <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">openDB</span>()
</span></span><span style="display:flex;"><span>  recentBlocks <span style="color:#ff79c6">:=</span> db.<span style="color:#50fa7b">GetRecentBlocks</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">for</span> _, block <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> recentBlocks {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">processBlock</span>(block); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">saveBlock</span>(block); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">updateBlockOperationCaches</span>(block); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">panic</span>(err)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">...</span> <span style="color:#6272a4">// Do more operations...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre><p>In the example above, we need to read the program from top to bottom to fully understand what it must do. Each function makes sense
in isolation, mostly due to a descriptive name, but it is hard to reason about how they fit together until one
reads this <code>main()</code> function in its entirety. <strong>Maybe you didn't want to save any block if any block in the batch failed to process</strong>.
This is harder to spot if you had a more complex codebase, and can sneak up on you without the compiler protecting you from the
bad intent of the code.</p>
<p>Functional programming (FP) flips this paradigm on its head. Instead, it follows a model of &quot;declative programming&quot; where we
declare programs in terms of what things <em>are</em> rather than procedures to be done. FP treats types, functions, and definitions
as first-class citizens, and only allows deterministic, pure functions! In FP, all functions only depend on their input,
cannot mutate data, and can only <em>transform</em> their inputs into new values in a deterministic manner.</p>
<p>To illustrate, here's how we could produce a list of N <code>ones</code> in an imperative language (Go):</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">ones</span>(n <span style="color:#8be9fd">int</span>) []<span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>  result <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">int</span>, n)
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; n; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>    result[i] = <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Whereas in Haskell, we can an infinite list of <code>ones</code> in a simple way:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#50fa7b">ones</span> <span style="color:#ff79c6">::</span> [<span style="color:#8be9fd">Integer</span>] <span style="color:#6272a4">-- This is the type annotation. Ones is an (infinite) list of integers.</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">ones</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span><span style="color:#8be9fd">:</span>ones     <span style="color:#6272a4">-- The &#34;:&#34; is the list append operator in Haskell.</span>
</span></span></code></pre><p>In Go, we have to define a procedure to get us a list of ones with a certain length, while in Haskell
we can define a recursive type that tells you exactly what <code>ones</code> is. The best part is this definition
is <em>lazy</em> because we aren't actually computing an infinite list (which would blow up our computer). Instead,
we are merely defining what <code>ones</code> is, and then any other function could take any N numbers from this infinite
list as desired. We can do the same for prime numbers, natural numbers, or any other infinite sequence using
a functional, lazy definition.</p>
<p>In functional programming, function type signatures and their contents are enough to tell you what
exactly something is, sometimes in a visually striking manner. Here is how we would implement the popular
<code>quicksort</code> algorithm in this manner:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#50fa7b">quicksort</span> <span style="color:#ff79c6">::</span> (<span style="color:#8be9fd">Ord</span> a) <span style="color:#ff79c6">=&gt;</span> [a] <span style="color:#ff79c6">-&gt;</span> [a] <span style="color:#6272a4">-- Type annotation of the quicksort function.</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">quicksort</span> <span style="color:#8be9fd">[]</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">[]</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">quicksort</span> (x<span style="color:#8be9fd">:</span>xs) <span style="color:#ff79c6">=</span>                <span style="color:#6272a4">-- Pattern matching a list with head element `x` and a tail `xs`</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">let</span> smaller <span style="color:#ff79c6">=</span> quicksort (filter (<span style="color:#ff79c6">&lt;=</span>x) xs) <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">let</span> bigger <span style="color:#ff79c6">=</span> quicksort (filter (<span style="color:#ff79c6">&gt;</span>x) xs) <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>  smaller <span style="color:#ff79c6">++</span> [x] <span style="color:#ff79c6">++</span> bigger
</span></span></code></pre><p>Instead of teling us a procedure for quicksorting with for-loops, we get a definition that visually depicts
what is going on in this recursive algorithm.</p>
<p><code>quicksort [4, 3, 5, 1, 2]</code> becomes</p>
<pre><code>quicksort ([3, 1, 2]) ++ [4] ++ quicksort [5]
quicksort ([1, 2]) ++ [3] ++ [4] ++ quicksort [5]
quicksort [1] ++ [2] ++ [3] ++ [4] ++ quicksort [5]
[1] ++ [2] ++ [3] ++ [4] ++ [5]
[1, 2, 3, 4 5]
</code></pre>
<p>In functional programs, we define deterministic outputs in terms
of inputs. In the example above, quicksorting an empty list just returns an empty list.</p>
<h2>I won't switch to Haskell – how will this help me as an engineer?</h2>
<p>Thinking functionally extends beyond Haskell and helps us brainstorm new ways of designing software that is easier to
maintain, test, and define. With fp, you can:</p>
<ul>
<li>Better manage your responsibilities when writing imperative software</li>
<li>Understand how to &quot;think with types&quot;, even in imperative code such as Go or Rust</li>
<li>Learn cleaner abstractions that can better express the intent of your software</li>
</ul>
<p>With fp, you can practice how to represent what you want your software to do in a more concise manner:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#ff79c6">let</span> (validBlocks, invalidBlocks) <span style="color:#ff79c6">=</span> partition checkValidity incomingBlocks
</span></span></code></pre><h2>What's wrong with imperative programs?</h2>
<p>Imperative programming is a pretty natural way of mapping a set of instructions to &quot;get things done&quot; in software.
Sometimes, procedures in imperative programs can be hundreds of lines of code, where we are accessing and updating databases, making
HTTP calls, interacting with end-users, and more. That kind of code can be hard to read and hard to maintain. On top of that,
a lot of imperative code is neither deterministic nor pure, as we often introduce <strong>side-effects</strong> that are unintended in our programs.</p>
<p>Let's say we want to write an imperative program that writes down a procedure for putting together a sandwich.
We might do something like this:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span>sandwich.buns = <span style="color:#50fa7b">prepareBuns</span>()
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> <span style="color:#50fa7b">wantCheese</span>() {
</span></span><span style="display:flex;"><span>  sandwich.cheeses = <span style="color:#50fa7b">inputCheeses</span>()
</span></span><span style="display:flex;"><span>} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>  sandwich.cheeses = <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sandwich.decideSauce = <span style="color:#50fa7b">inputSauce</span>()
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">return</span> sandwich
</span></span></code></pre><p>In the code above, we mutate sandwich along the way, and nothing stops us from doing something crazy such as
making an HTTP request in the middle, or maybe sending an email when all we want is to build a sandwich!</p>
<h3>Thinking in types changes everything</h3>
<p>Instead of saying how to build a sandwich, let's define what a sandwich <em>is</em>. In Haskell,
we &quot;think in types&quot; and build our entire definitions around type sets we have full control over.</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#ff79c6">data</span> <span style="color:#8be9fd">Sandwich</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">SquareBun</span> <span style="color:#8be9fd">Filling</span> (<span style="color:#8be9fd">Maybe</span> <span style="color:#8be9fd">Cheese</span>) [<span style="color:#8be9fd">Sauce</span>] 
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">BurgerBun</span> <span style="color:#8be9fd">Filling</span> (<span style="color:#8be9fd">Maybe</span> <span style="color:#8be9fd">Cheese</span>) [<span style="color:#8be9fd">Sauce</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">HotDogBun</span> [<span style="color:#8be9fd">Sauce</span>]                        <span style="color:#6272a4">-- Yes hotdogs are sandwiches.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">data</span> <span style="color:#8be9fd">Filling</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">Ham</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Turkey</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">PeanutButter</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">data</span> <span style="color:#8be9fd">Cheese</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">American</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Swiss</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">PepperJack</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Cheddar</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">data</span> <span style="color:#8be9fd">Sauce</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">Ketchup</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Mustard</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Mayo</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Relish</span> <span style="color:#ff79c6">|</span> <span style="color:#8be9fd">Jelly</span>
</span></span></code></pre><p>From here, instead of needing to define a <em>procedure</em> to build a sandwich as a series of steps,
we simply define what a school lunch sandwich actually is in terms of its parts.</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#50fa7b">schoolLunch</span> <span style="color:#ff79c6">::</span> <span style="color:#8be9fd">Sandwich</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">schoolLunch</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd">SquareBun</span> <span style="color:#8be9fd">PeanutButter</span> <span style="color:#8be9fd">Nothing</span> [<span style="color:#8be9fd">Jelly</span>] <span style="color:#6272a4">-- No cheese because ew.</span>
</span></span></code></pre><p>A school lunch above is simply a square-bun, pb&amp;j sandwich! No need for an ordered mutation of sandwich data
when we can simply declare what we want.</p>
<h3>Technical debt</h3>
<p>Functional programs tend to be comprised of many small functions that can be understood individually, whereas imperative programs
tend to grow into mega-sized functions and procedures that make refactoring a pain, and reasoning about the whole
program difficult. This is because <strong>procedural order is key to imperative programs</strong>. Imperative code is <strong>easy to write but hard to read</strong>.
When your code is being developed in a team environment, and a previous developer was the only one that understood all the logic
of a critical, 1000-line function, you might be in trouble. Modifying even a single line of a procedure could <strong>cripple
a program or introduce a serious bug</strong>, making it easier to grow technical debt.</p>
<h3>Side-effects</h3>
<p>In procedural code, your operations can have unintended side-effects, because functions will be executed top-down as a series
of instructions without guarantees of determinism. In the middle of a for-loop, your code could access a database operation that
fails while you have already updated another database record before, leaving you in an inconsistent state. Because data is mutable,
your code can also suffer <strong>data-races</strong>, which are often patched up less-than-ideal tools.</p>
<p><strong>In pure, functional programs there can be no data races</strong> because your data is <strong>immutable</strong> and each function is a
deterministic transformation from inputs to outputs. That is, side-effects are not allowed.</p>
<blockquote>
<p>No side-effects?! That seems impractical in the real world!</p>
</blockquote>
<p>It sounds impossible to have a useful program that <em>does not</em> have side-effects, as we use these all the time in
imperative programs to do valuable things. What alternative do we have in fp? It turns out we have a way of using
really cool techniques to kind of &quot;emulate&quot; imperative code using pure functions and still maintaining
some awesome guarantees which we'll cover in this series.</p>
<p>In imperative code, however, your software could be doing something like this:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;"><code><span style="display:flex;"><span><span style="color:#6272a4">// Simple addition of two integers.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">addNumbers</span>(x, y <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#50fa7b">launch_missiles</span>() <span style="color:#6272a4">// Here be dragons...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">return</span> x <span style="color:#ff79c6">+</span> y
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Although the example above is contrived, it is harder to stop bad side-effects when your functions are thousands of lines
long and have unclear naming. These kinds of dangerous side-effects <em>cannot</em> happen in a pure functional language such
as Haskell without making it obvious to the developer, because programs are transformations of data type declarations
rather than impure, ordered computation.</p>
<h2>Series overview</h2>
<p>Over the course a blog series, we will be covering the major aspects of writing pure, functional code with real-world
examples and without any fancy math to go with it. We'll be introducing hard concepts in terms of what they can do for us
that other methods cannot, and wrap up the series with an analysis of how you can use this information especially if you
plan to continue working with imperative codebases (I am a Go developer myself!). The series outline is as follows:</p>
<ul>
<li>Thinking functionally</li>
<li>Pure operations only! ...But what if I need side-effects?!</li>
<li>Thinking in types and DSLs</li>
<li>The cleanest code: interpretable programs</li>
<li>Writing real programs in a functional language</li>
<li>Why functional programming is not taking over the world yet</li>
</ul>
<p>Stay tuned, as each post will be packed with content. I hope this peaks your interest as much as it has been a joy for me
to bring these ideas to developers that are not yet familiar with them.</p>

</div>

<div class="comments">
	
<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
		this.page.url = 'https://rauljordan.com/\/2022\/09\/22\/part-i-functional-programming-for-ethereum.html';
		this.page.identifier = '\/2022\/09\/22\/part-i-functional-programming-for-ethereum.html';
		this.page.title = 'Blog Series: Pure, functional programming for modern blockchain development';
	};

	(function () {
		var d = document, s = d.createElement('script');

		s.src = '//rauljordanblog-1.disqus.com/embed.js';

		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
		powered by Disqus.</a></noscript>

</div>

		</div>
	</main>
	
<footer class="site-footer">
	<div class="wrapper">
		<div class="credits">Made With Golang <i class="fas fa-heart"></i></div>
	</div>
</footer>

	<script>
		window.FontAwesomeConfig = {
			searchPseudoElements: true
		}
	</script>
</body>

</html>
