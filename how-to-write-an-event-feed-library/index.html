<!DOCTYPE html>
<html lang="en">

<head>
    <title>rauljordan::blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://rauljordan.com/style.css">
    <link rel="stylesheet" href="https://rauljordan.com/color/orange.css">

        <link rel="stylesheet" href="https://rauljordan.com/color/background_pink.css">
    
    <link rel="stylesheet" href="https://rauljordan.com/font-hack-subset.css">

        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://rauljordan.com/rss.xml">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@rauljordaneth">
    <meta name="twitter:creator" content="@rauljordaneth">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://rauljordan.com" />
    <meta property="og:site_name" content="rauljordan::blog" />

    
<meta property="og:title" content="Writing an One-to-Many Event Feed Library in Go" />
<meta property="og:locale" content="en_US" />
<meta property="og:description" content="" />
<meta property="og:site_name" content="rauljordan::blog" />
<meta property="og:image" content="" />
<meta property="og:type" content="article" />

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:title" content="Writing an One-to-Many Event Feed Library in Go" />
<meta property="twitter:image" content="" />
<meta property="twitter:description" content="" />
<meta name="twitter:site" content="@rauljordaneth" />
<meta name="twitter:creator" content="@rauljordaneth" />

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-53062950-12"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-53062950-12');
    </script>
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://rauljordan.com" style="text-decoration: none;">
                    <div class="logo">
                      
                            rauljordan::blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://rauljordan.com/tags">tags</a></li>
            
                <li><a href="https://rauljordan.com/archive">archive</a></li>
            
                <li><a href="https://rauljordan.com/about-me">about me</a></li>
            
                <li><a href="https://twitter.com/rauljordaneth" target="_blank" rel="noopener noreferrer">twitter</a></li>
            
                <li><a href="https://github.com/rauljordan" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://rauljordan.com/how-to-write-an-event-feed-library/">Writing an One-to-Many Event Feed Library in Go</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2019-09-23
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://rauljordan.com/tags/golang/">#golang</a></span>
    

        
        <div class="post-content">
            <pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">sub </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    feed         </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed
</span><span>    channelIndex </span><span style="font-style:italic;color:#39bae6;">int
</span><span>    channel      </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool
</span><span>    once         sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Once
</span><span>    err          </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error
</span><span>}
</span></code></pre>
<p>This blog post explores the design rationale behind building a performant, simple, one-to-many event feed library in Go. We'll be recreating the event library from the <a href="https://github.com/ethereum/go-ethereum/blob/master/event/feed.go">go-ethereum</a> project step by step, even explaining some of the tricky design decisions behind its robust concurrency approach. </p>
<span id="continue-reading"></span><h1 id="ping-pong">Ping Pong</h1>
<p>When I first started learning Go, I didn't truly understand the <em>fantastic</em> concurrency primitives the language provides. Most real world applications tend to be concurrent and asynchronous...meaning all sorts of things can and will happen simultaneously and at different time intervals, often beyond our control. A big challenge when building concurrent applications is then the control and flow of shared state information, often becoming a very complex problem. In Go, communication between concurrent threads happens through special data structures called <strong>channels</strong>, which are <em>typed</em> and allow for a basic &quot;sender&quot; vs. &quot;listener&quot; design pattern. This pattern, as we'll soon see, is more expressive than it seems, giving Go one of the strongest toolkits to handle even the most complex concurrency challenges.</p>
<p>Let's take a look at a basic example:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">package </span><span>main
</span><span>
</span><span style="color:#ff7733;">import </span><span>(
</span><span>    </span><span style="color:#c2d94c;">&quot;fmt&quot;
</span><span>    </span><span style="color:#c2d94c;">&quot;time&quot;
</span><span>)
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span>)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">ping</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">pong</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">select </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">ping</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span>) {
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        time</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Sleep</span><span>(time</span><span style="color:#f29668;">.</span><span>Second)
</span><span>        fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Sending message...&quot;</span><span>)
</span><span>        ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#c2d94c;">&quot;ping&quot;
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">pong</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span>) {
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span>p </span><span style="color:#f29668;">:=&lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Received message </span><span style="color:#f29718;">%s</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>p)
</span><span>            </span><span style="color:#ff7733;">if </span><span>p </span><span style="color:#f29668;">== </span><span style="color:#c2d94c;">&quot;ping&quot; </span><span>{
</span><span>                fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;pong&quot;</span><span>)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>In the example above, we created two functions, <code>ping</code> and <code>pong</code>. The first one sends the &quot;ping&quot; message over a string typed channel, while the other listens for and receives the message, checking its value, and logging &quot;pong&quot; accordingly. We spawn off both functions concurrently using the <code>go</code> keyword, which creates a lightweight thread called a <em>goroutine</em> that runs alongside the main thread of the program. Having channels abstracts away the complexity of goroutine communication, making users unaware of the concurrency details happening underneath the hood and leaving us to simply focus on our core application logic.</p>
<p><img src="https://toivjon.files.wordpress.com/2017/11/javafx-pong.png?w=772" alt="image" /></p>
<h2 id="gotchas-buffered-vs-unbuffered-channels">Gotchas: Buffered vs. Unbuffered Channels</h2>
<p>When creating a Go channel, we have the option of making it either buffered or unbuffered. An unbuffered channel is initialized with a simple make call along with its type, <code>make(chan bool)</code>. A buffered channel instead specifies a <code>buffer</code> length, such as <code>make(chan bool, 5)</code>. Think of channels as the mailman, bringing packages all across the neighborhood. The buffer is the the capacity of his mailbag, containing all the envelopes. The mailman will wait till his bag is full before making a trip to deliver the letters. Whenever you specify a buffered channel, that's what happens. Essentially, data is kept in the buffer until it fills up to capacity, and at that point a listener or receiver can read all of the information contains in the channel. An unbuffered channel, however, has a capacity of 0, so it can't store data. Every send over an unbuffered channel <em>must</em> have a recipient ready to process the send right away.</p>
<p>Let's take a look at a basic unbuffered example:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span>)
</span><span>    </span><span style="color:#ff7733;">go func</span><span>() {
</span><span>        ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#c2d94c;">&quot;hello world&quot;
</span><span>    }()
</span><span>    msg </span><span style="color:#f29668;">:= &lt;-</span><span>ch
</span><span>    fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(msg)
</span><span>}
</span></code></pre>
<p>We create a listener over our basic, unbuffered channel and log once we receive it, great! If we run this program we see our little &quot;hello world&quot; pop up on our terminal window. If we never send, the program will wait forever, given the recipient will hang there never receiving a message to proceed into the Println statement.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span>)
</span><span>    </span><span style="color:#ff7733;">go func</span><span>() {
</span><span>        ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#c2d94c;">&quot;hello world&quot;
</span><span>    }()
</span><span>    msg </span><span style="color:#f29668;">:= &lt;-</span><span>ch
</span><span>    fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(msg)
</span><span>}
</span></code></pre>
<p>What happens if we try to send and receive in the same goroutine with an unbuffered channel?</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">string</span><span>)
</span><span>    ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#c2d94c;">&quot;hello world&quot;
</span><span>    msg </span><span style="color:#f29668;">:= &lt;-</span><span>ch
</span><span>    fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(msg)
</span><span>}
</span></code></pre>
<p>Running...</p>
<pre data-lang="bash" style="background-color:#0f1419;color:#bfbab0;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb454;">$</span><span> go run main.go
</span><span style="color:#ffb454;">fatal</span><span> error: all goroutines are asleep - deadlock!
</span><span>
</span><span style="color:#ffb454;">goroutine</span><span> 1 </span><span style="color:#ff7733;">[</span><span>chan send</span><span style="color:#ff7733;">]</span><span>:
</span><span style="color:#ffb454;">main.main</span><span>()
</span></code></pre>
<p><img src="https://raw.githubusercontent.com/MariaLetta/free-gophers-pack/master/illustrations/png/2.png" alt="image" /></p>
<p>Yikes! Well the issue is pretty clear here, as there's no listener, the channel will <em>block</em> the main thread on sending, preventing it from advancing at all! Even if we add a listener right beneath the send, we will get the same error because the code can <em>never</em> proceed past <code>ch &lt;- &quot;hello world&quot;</code>, as the send call never even completes. There must already be a listener prepared to receive when the <code>send</code> is called. </p>
<blockquote>
<p>You cannot send and receive from an unbuffered channel in the same goroutine, as there needs to be a receiver ready before you send anything out!</p>
</blockquote>
<p>The code above works if we initialize our channel with a buffer <code>ch := make(chan string, 1)</code>, as the channel will then store the data until a listener reads it even if there is no listener ready at the time of sending.</p>
<h2 id="why-buffered-channels-are-great">Why Buffered Channels Are Great</h2>
<p>Buffered channels have a fundamentally different use case than unbuffered ones, as by their very nature, they're well-suited to handle aggregation of information across goroutines. For example, say you're creating a concurrent web scraper that tries to scrape a ton of websites at the same time, and eventually you want to aggregate the results into some nice form for final processing. If you know the list of websites you'll be scraping ahead of time, you can create a buffered channel of that length, do the heavy lifting across a bunch of concurrent goroutines, and write the results to this channel. When you're done, a listener will be ready to loop over the aggregated results and handle them accordingly. Let's take a look:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">ScrapedData </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    Url      </span><span style="font-style:italic;color:#39bae6;">string
</span><span>    Html     </span><span style="font-style:italic;color:#39bae6;">string
</span><span>    NumLinks </span><span style="font-style:italic;color:#39bae6;">int
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">scrapeSite</span><span>(</span><span style="color:#f29718;">s </span><span style="font-style:italic;color:#39bae6;">string</span><span>) </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ScrapedData </span><span>{
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Do some intense data scraping...
</span><span>    htmlResult </span><span style="color:#f29668;">:= </span><span style="color:#ffb454;">getHtmlResults</span><span>(s)
</span><span>    numLinks </span><span style="color:#f29668;">:= </span><span style="color:#ffb454;">getNumLinks</span><span>(htmlResult)
</span><span>    </span><span style="color:#f29668;">...
</span><span>    </span><span style="color:#ff7733;">return </span><span style="color:#f29668;">&amp;</span><span>ScrapedData{
</span><span>        Url</span><span style="color:#bfbab0cc;">: </span><span>s</span><span style="color:#bfbab0cc;">,
</span><span>        Html</span><span style="color:#bfbab0cc;">:     </span><span>htmlResults</span><span style="color:#bfbab0cc;">,
</span><span>        NumLinks</span><span style="color:#bfbab0cc;">: </span><span>numLinks</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    websites </span><span style="color:#f29668;">:= </span><span>[]</span><span style="font-style:italic;color:#39bae6;">string</span><span>{</span><span style="color:#c2d94c;">&quot;example.com&quot;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&quot;wikipedia.org&quot;</span><span>}
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ScrapedData</span><span style="color:#bfbab0cc;">, </span><span style="color:#f07178;">len</span><span>(websites))
</span><span>
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(websites)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        </span><span style="color:#ff7733;">go func</span><span>(</span><span style="color:#f29718;">ii </span><span style="font-style:italic;color:#39bae6;">int</span><span>) {
</span><span>            ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#ffb454;">scrapeSite</span><span>(websites[ii])
</span><span>        }(i)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">for </span><span>val </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>ch {
</span><span>        fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Scraped </span><span style="color:#f29718;">%s</span><span style="color:#c2d94c;"> with number of links </span><span style="color:#f29718;">%d</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>Url</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>NumLinks)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Using the concepts from before, we declare a <em>buffered</em> channel of type <code>*ScrapedData</code>. Then, for every website, we spawn off a goroutine that does some heavy data scraping and writes the result to the channel. In the end, we loop over the results and print out every single value we just scraped. Does the code above run? Let's see:</p>
<pre data-lang="bash" style="background-color:#0f1419;color:#bfbab0;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb454;">$</span><span> go run main.go
</span><span style="color:#ffb454;">Scraped</span><span> example.com with number of links 10
</span><span style="color:#ffb454;">Scraped</span><span> wikipedia.org with number of links 20
</span><span style="color:#ffb454;">fatal</span><span> error: all goroutines are asleep - deadlock!
</span><span>
</span><span style="color:#ffb454;">goroutine</span><span> 1 </span><span style="color:#ff7733;">[</span><span>chan receive</span><span style="color:#ff7733;">]</span><span>:
</span><span style="color:#ffb454;">main.main</span><span>()
</span></code></pre>
<p>Shoot - what the heck happened here? As it turns out, Go's <code>range</code> function isn't smart enough to figure out we're done writing into the channel, and that's not its fault! Given we're building some concurrent application, there could be some other routine that tries to keep writing into the channel, so there's no way for <code>range</code> to know we're done writing, even if the channel is filled up to the brim. Instead, once we're done writing and we're sure of it, we should call Go's built-in <code>close</code> operator to close the channel off for future communication.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    websites </span><span style="color:#f29668;">:= </span><span>[]</span><span style="font-style:italic;color:#39bae6;">string</span><span>{</span><span style="color:#c2d94c;">&quot;example.com&quot;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&quot;wikipedia.org&quot;</span><span>}
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ScrapedData</span><span style="color:#bfbab0cc;">, </span><span style="color:#f07178;">len</span><span>(websites))
</span><span>
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(websites)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        </span><span style="color:#ff7733;">go func</span><span>(</span><span style="color:#f29718;">ii </span><span style="font-style:italic;color:#39bae6;">int</span><span>) {
</span><span>            ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#ffb454;">scrapeSite</span><span>(websites[ii])
</span><span>        }(i)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#f07178;">close</span><span>(ch)
</span><span>
</span><span>    </span><span style="color:#ff7733;">for </span><span>val </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>ch {
</span><span>        fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Scraped </span><span style="color:#f29718;">%s</span><span style="color:#c2d94c;"> with number of links </span><span style="color:#f29718;">%d</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>Url</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>NumLinks)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Turns out this eliminates the deadlock error, but nothing else gets printed out...what gives? Concurrent applications are often <em>asynchronous</em>, meaning we don't know when they'll complete relative to other threads and we should not make any assumptions regarding this. In the code above, when we spawn off two goroutines, the main thread keeps going, there's nothing stopping it! <em>So the <code>close</code> call might have happened way before we attempt to scrape the data</em>, leaving us in a weird spot. As a solution, Go provides an awesome tool called a <code>WaitGroup</code>, which lets us block threads until a specified number of goroutines complete.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    websites </span><span style="color:#f29668;">:= </span><span>[]</span><span style="font-style:italic;color:#39bae6;">string</span><span>{</span><span style="color:#c2d94c;">&quot;example.com&quot;</span><span style="color:#bfbab0cc;">, </span><span style="color:#c2d94c;">&quot;wikipedia.org&quot;</span><span>}
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ScrapedData</span><span style="color:#bfbab0cc;">, </span><span style="color:#f07178;">len</span><span>(websites))
</span><span>
</span><span>    </span><span style="color:#ff7733;">var </span><span>wg sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">WaitGroup
</span><span>    wg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Add</span><span>(</span><span style="color:#f07178;">len</span><span>(websites))
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(websites)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        </span><span style="color:#ff7733;">go func</span><span>(</span><span style="color:#f29718;">ii </span><span style="font-style:italic;color:#39bae6;">int</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">w </span><span style="color:#f29668;">*</span><span>sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">WaitGroup</span><span>) {
</span><span>            ch </span><span style="color:#f29668;">&lt;- </span><span style="color:#ffb454;">scrapeSite</span><span>(websites[ii])
</span><span>            w</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Done</span><span>()
</span><span>        }(i</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29668;">&amp;</span><span>wg)
</span><span>    }
</span><span>
</span><span>    wg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Wait</span><span>()
</span><span>    </span><span style="color:#f07178;">close</span><span>(ch)
</span><span>
</span><span>    </span><span style="color:#ff7733;">for </span><span>val </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>ch {
</span><span>        fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Scraped </span><span style="color:#f29718;">%s</span><span style="color:#c2d94c;"> with number of links </span><span style="color:#f29718;">%d</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>Url</span><span style="color:#bfbab0cc;">, </span><span>val</span><span style="color:#f29668;">.</span><span>NumLinks)
</span><span>    }
</span><span>}
</span></code></pre>
<p>Using a wait group, we can tell the program &quot;hey, we have 2 goroutines that are scheduled, wait until they're finished before proceeding&quot;. When the goroutine finishes, we can call <code>wg.Done()</code> to notify the wait group. Note we pass in a reference to the wait group in the goroutine's arguments to ensure we don't make a different copy of the wait group we initialized. <em>Now</em>, when we run the code again, we'll wait till all routines complete before we close off the channel, and we should have a fully functional program now with wait groups, fancy buffered channels, and even a range loop to read the aggregated data results :).</p>
<pre data-lang="bash" style="background-color:#0f1419;color:#bfbab0;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb454;">$</span><span> go run main.go
</span><span style="color:#ffb454;">Scraped</span><span> example.com with number of links 10
</span><span style="color:#ffb454;">Scraped</span><span> wikipedia.org with number of links 20
</span></code></pre>
<h2 id="one-to-many-subscriptions">One-to-Many Subscriptions</h2>
<p>Now that we reviewed buffered and unbuffered channels as well as goroutines, let's see what else this powerful construct allows us to build. So far, we've only seen single sender vs. receiver patterns, where there's a single listener waiting for results sent into some channel. But what if we want many listeners to receive the same data and do something with it <em>simultaneously</em>? This should work, right?</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">var </span><span>userID </span><span style="color:#f29668;">= </span><span style="color:#f29718;">0
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">UserInfo </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    ID </span><span style="font-style:italic;color:#39bae6;">int
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">UserInfo</span><span>)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">simulateUserSignup</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">sendEmail</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">saveUserToDB</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">select </span><span>{}
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">simulateUserSignup</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">UserInfo</span><span>) {
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        time</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Sleep</span><span>(time</span><span style="color:#f29668;">.</span><span>Second)
</span><span>        ch </span><span style="color:#f29668;">&lt;- &amp;</span><span>UserInfo{
</span><span>            ID</span><span style="color:#bfbab0cc;">: </span><span>userID</span><span style="color:#bfbab0cc;">,
</span><span>        }
</span><span>        userID</span><span style="color:#f29668;">++
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">sendEmail</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">UserInfo</span><span>) {
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span>user </span><span style="color:#f29668;">:= &lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Sending confirmation email to user with ID </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">...</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>user</span><span style="color:#f29668;">.</span><span>ID)
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">saveUserToDB</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">UserInfo</span><span>) {
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span>user </span><span style="color:#f29668;">:= &lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Saving user data to database with ID </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">...</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>user</span><span style="color:#f29668;">.</span><span>ID)
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>The output...</p>
<pre data-lang="bash" style="background-color:#0f1419;color:#bfbab0;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb454;">$</span><span> go run main.go
</span><span style="color:#ffb454;">Saving</span><span> user data to database with ID 0...
</span><span style="color:#ffb454;">Sending</span><span> confirmation email to user with ID 1...
</span><span style="color:#ffb454;">Saving</span><span> user data to database with ID 2...
</span><span style="color:#ffb454;">Sending</span><span> confirmation email to user with ID 3...
</span><span style="color:#ffb454;">Saving</span><span> user data to database with ID 4...
</span><span style="color:#ffb454;">Sending</span><span> confirmation email to user with ID 5...
</span><span style="color:#ffb454;">Saving</span><span> user data to database with ID 6...
</span><span style="color:#ffb454;">Sending</span><span> confirmation email to user with ID 7...
</span><span style="color:#ffb454;">Saving</span><span> user data to database with ID 8...
</span></code></pre>
<p>Oh no...we <em>really</em> don't that to happen. We want <strong>both</strong> the sending of a confirmation email + the saving a user to the DB to happen together, not skipping every other user! Turns out, naïve channels don't exactly work when you need a one-to-many subscription pattern. We could indeed rearchitect the code above to instead listen once and perform both actions sequentially and synchronously:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">UserInfo</span><span>)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">simulateUserSignup</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span>user </span><span style="color:#f29668;">:= &lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Saving user data to database with ID </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">...</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>user</span><span style="color:#f29668;">.</span><span>ID)
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// Perform the db save...
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Sending confirmation email to user with ID </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">...</span><span style="color:#95e6cb;">\n</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>user</span><span style="color:#f29668;">.</span><span>ID)
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// Send the confirmation email...
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>And sure, this is the <em>best</em> solution if your entire application is a single event loop, but more complex applications typically have various services running concurrently with their own event loops, and having everything work in this synchronous pattern isn't always the best. Sometimes, we want to simply trigger events in our applications without worrying too much about who's listening, with the possibility of having infinitely many listeners that can conditionally <strong>subscribe</strong> to the event notification. This common pattern is conventionally referred to as <code>PubSub</code>. A naïve implementation of a one-to-many pubsub with a single channel won't work for this use case, as we see above, there can only be at most 1 listener that receives a single send at any given time. However, can we use these channel primitives to come with a one-to-many implementation that is simple and robust enough to use in production?</p>
<h2 id="designing-a-subscription-and-event-feed-model">Designing a Subscription and Event Feed Model</h2>
<p>We're going to be designing a <code>Feed</code> data structure that allows many listeners to subscribe to a single event sent over the feed and receive them as they happen. First, let's outline some feature requirements we'd like to see in any library that implements this pubsub model using Go:</p>
<ul>
<li>We want a <em>generic</em> library, I want to be able to trigger events with any sort of data, regardless of its type</li>
<li>We want the ability for many subscribers to listen for event triggers of a specific type, each receiving the sent data <em>simultaneously</em> as it occurs</li>
<li>We want the ability for subscribers to <em>unsubscribe</em> whenever they need to, preventing future events being received by such listener</li>
<li>We want a library that is easy to use, idiomatic, and uses Go's concurrency primitives effectively</li>
<li>We want a library that is light on memory, performance, and is thread-safe</li>
</ul>
<h2 id="a-first-pass-implementation">A First Pass Implementation</h2>
<p>So, where do we start? A good design typically begins by identifying the key invariants of necessary features. We want to focus first on the core desired functionality, which is to allow for <strong>one-to-many</strong> subscriptions of triggered events. To keep things simple, our first implementation will only allow for <code>bool</code> type event subscriptions, so let's call our feed a <code>BoolFeed</code>.</p>
<p>Given a single channel send can only receive data by at most one listener, why don't we allow our library to send to a bunch of registered channels simultaneously? That is, we can allow listeners to <em>register</em> a channel they want to be notified through, and as we trigger a new event, we send data over all the registered channels via a for loop. Let's give that a shot:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">BoolFeed </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    lock sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Mutex
</span><span>    listeners []</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">Send</span><span>(</span><span style="color:#f29718;">data </span><span style="font-style:italic;color:#39bae6;">bool</span><span>) {
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    </span><span style="color:#ff7733;">for </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span>lis </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>f</span><span style="color:#f29668;">.</span><span>listeners {
</span><span>        lis</span><span style="color:#f29668;">&lt;-</span><span>data
</span><span>    }
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">RegisterListener</span><span>(</span><span style="color:#f29718;">lis </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>) {
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    f</span><span style="color:#f29668;">.</span><span>listeners </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(f</span><span style="color:#f29668;">.</span><span>listeners</span><span style="color:#bfbab0cc;">, </span><span>lis)
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">firstListener</span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>)
</span><span>    f</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterListener</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span style="color:#f29668;">&lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Received data in first listener&quot;</span><span>)
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">secondListener</span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>)
</span><span>    f</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterListener</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span style="color:#f29668;">&lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Received data in second listener&quot;</span><span>)
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    feed </span><span style="color:#f29668;">:= &amp;</span><span>BoolFeed{
</span><span>        listeners</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>([]</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">go func</span><span>(</span><span style="color:#f29718;">ff </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) {
</span><span>        </span><span style="color:#ff7733;">for </span><span>{
</span><span>            time</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Sleep</span><span>(time</span><span style="color:#f29668;">.</span><span>Second)
</span><span>            ff</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Send</span><span>(</span><span style="color:#f29718;">true</span><span>)
</span><span>        }
</span><span>    }(feed)
</span><span>
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">firstListener</span><span>(feed)
</span><span>    </span><span style="color:#ff7733;">go </span><span style="color:#ffb454;">secondListener</span><span>(feed)
</span><span>    </span><span style="color:#ff7733;">select </span><span>{}
</span><span>}
</span></code></pre>
<p>We use a mutex above to make the operations thread safe, preventing calls to <code>RegisterListener</code> from happening at the exact same time as we're doing a send of the data over the currently registered channels. We run the code, and...</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span>$ </span><span style="color:#ff7733;">go </span><span>run main</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">go
</span><span>Received data in second listener
</span><span>Received data in first listener
</span><span>Received data in second listener
</span><span>Received data in first listener
</span><span>Received data in first listener
</span></code></pre>
<p>It works, we see data being properly received by the different listeners. Even though we get the result we expected in this contrived example, <em><strong>our naïve approach still has a critical limitation that makes it unsuitable for production</strong></em> which we'll analyze in the next sections.</p>
<p>For now, let's see if we can meet another invariant in our features requirement, which is to unsubscribe from the event triggers whenever want to. For this, we can define a <code>Subscription</code> type, which contains an <code>Unsubscribe()</code> method, and which can be returned by the <code>RegisterListener</code> function. As a subscriber, we don't care about how this unsubscribing by itself works underneath the hood, we just need to have it as an option. For easier testing and implementation, we can define subscriptions as a Go interface:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Subscription </span><span style="color:#ff7733;">interface </span><span>{
</span><span>    </span><span style="color:#ffb454;">Unsubscribe</span><span>()
</span><span>}
</span></code></pre>
<p>and amend our <code>BoolFeed</code> as follows:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">RegisterListener</span><span>() </span><span style="color:#ff7733;">Subscription
</span></code></pre>
<p>While we're at it, let's make our implementation more idiomatic and rename <code>RegisterListener</code> to <code>Subscribe</code> to end up with:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">Subscribe</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>) </span><span style="color:#ff7733;">Subscription </span><span>{
</span><span>    </span><span style="color:#f29668;">...
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">someListener</span><span>(</span><span style="color:#f29718;">feed </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>)
</span><span>    sub </span><span style="color:#f29668;">:= </span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Subscribe</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">defer </span><span>sub</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unsubscribe</span><span>()
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span style="color:#f29668;">&lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Received data in first listener&quot;</span><span>)
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>But what if the feed we're subscribed to all of a sudden has problems, or maybe it belongs to another service that shuts down, how would we know? Indeed, every subscription should have an <code>error</code> channel that we can also listen for and unsubscribe if needed.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Subscription </span><span style="color:#ff7733;">interface </span><span>{
</span><span>    </span><span style="color:#ffb454;">Unsubscribe</span><span>()
</span><span>    </span><span style="color:#ffb454;">Err</span><span>() </span><span style="color:#f29668;">&lt;-</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">someListener</span><span>(</span><span style="color:#f29718;">feed </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) {
</span><span>    ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>)
</span><span>    sub </span><span style="color:#f29668;">:= </span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Subscribe</span><span>(ch)
</span><span>    </span><span style="color:#ff7733;">defer </span><span>sub</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unsubscribe</span><span>()
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="color:#ff7733;">select </span><span>{
</span><span>        </span><span style="color:#ff7733;">case </span><span style="color:#f29668;">&lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Println</span><span>(</span><span style="color:#c2d94c;">&quot;Received data in first listener&quot;</span><span>)
</span><span>        </span><span style="color:#ff7733;">case </span><span>err</span><span style="color:#f29668;">:=&lt;-</span><span>sub</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Err</span><span>()</span><span style="color:#bfbab0cc;">:
</span><span>            fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Printf</span><span>(</span><span style="color:#c2d94c;">&quot;Oh no - something went wrong: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>err)
</span><span>            </span><span style="color:#ff7733;">return
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now we have an easy, standard pattern to safely subscribe to and unsubscribe from events should errors occur as we listen for data. As we implement our <code>Unsubscribe()</code> function, we should ensure it can only occur <strong>once</strong> to prevent accidental duplicate calls to have detrimental effects.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#f29668;">...
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">Subscribe</span><span>(</span><span style="color:#f29718;">lis </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>) </span><span style="color:#ff7733;">Subscription </span><span>{
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    </span><span style="color:#ff7733;">defer </span><span>f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>    f</span><span style="color:#f29668;">.</span><span>listeners </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(f</span><span style="color:#f29668;">.</span><span>listeners</span><span style="color:#bfbab0cc;">, </span><span>lis)
</span><span>    </span><span style="color:#ff7733;">return </span><span style="color:#f29668;">&amp;</span><span>sub{
</span><span>        feed</span><span style="color:#bfbab0cc;">: </span><span>f</span><span style="color:#bfbab0cc;">,
</span><span>        channelIndex</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>listeners)</span><span style="color:#f29668;">-</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">,
</span><span>        channel</span><span style="color:#bfbab0cc;">: </span><span>lis</span><span style="color:#bfbab0cc;">,
</span><span>        err</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// removes an channel at index i efficiently as order does not
</span><span style="font-style:italic;color:#5c6773;">// matter for listeners we keep track of.
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed</span><span>) </span><span style="color:#ffb454;">remove</span><span>(</span><span style="color:#f29718;">i </span><span style="font-style:italic;color:#39bae6;">int</span><span>) {
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    f</span><span style="color:#f29668;">.</span><span>listeners[i] </span><span style="color:#f29668;">= </span><span>f</span><span style="color:#f29668;">.</span><span>listeners[</span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>listeners)</span><span style="color:#f29668;">-</span><span style="color:#f29718;">1</span><span>]
</span><span>    f</span><span style="color:#f29668;">.</span><span>listeners </span><span style="color:#f29668;">= </span><span>f</span><span style="color:#f29668;">.</span><span>listeners[</span><span style="color:#bfbab0cc;">:</span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>listeners)</span><span style="color:#f29668;">-</span><span style="color:#f29718;">1</span><span>]
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">sub </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    feed    </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">BoolFeed
</span><span>    channelIndex </span><span style="font-style:italic;color:#39bae6;">int
</span><span>    channel </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool
</span><span>    once sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Once
</span><span>    err     </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">sub</span><span>) </span><span style="color:#ffb454;">Unsubscribe</span><span>() {
</span><span>    s</span><span style="color:#f29668;">.</span><span>once</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Do</span><span>(</span><span style="color:#ff7733;">func</span><span>() {
</span><span>        s</span><span style="color:#f29668;">.</span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">remove</span><span>(s</span><span style="color:#f29668;">.</span><span>channelIndex)
</span><span>        </span><span style="color:#f07178;">close</span><span>(sub</span><span style="color:#f29668;">.</span><span>err)
</span><span>    })
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">sub</span><span>) </span><span style="color:#ffb454;">Err</span><span>() </span><span style="color:#f29668;">&lt;-</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error </span><span>{
</span><span>    </span><span style="color:#ff7733;">return </span><span>s</span><span style="color:#f29668;">.</span><span>sub
</span><span>}
</span></code></pre>
<p>Let's digest what's going on above. First, we returned a <code>&amp;sub{...}</code> from our <code>Subscribe</code> func, storing some information about the channel's index in the listeners, and we also initialize a useful <code>err</code> channel as a <em>buffered channel</em>. Remember how buffered channels don't block a thread on a send? Well, imagine that the error listener all of a sudden disappears for whatever reason, then if we were writing over an unbuffered channel, we'd have a send call that can never complete, causing us to have memory leakage! This is dangerous thing, as it leads to some of the most silent but deadly bugs you can have in an application. Having a buffered channel of size one ensures that a send over it will be non-blocking.</p>
<p>In our <code>Unsubscribe</code> function, we use the helpful <code>sync.Once</code> helper from the standard library to ensure we run the function once and only once. We remove the channel from the feed's internal list of listeners and then close our buffered sub channel to wrap things up nicely. Another interesting to note is the function signature for the <code>Err() &lt;-chan error</code> func. Specifying <code>&lt;-chan error</code> basically tells whomever uses this function that the returned channel is only capable of <em>receiving</em> data, preventing any external sends into the error channel. So far, our first implementation meets most of the invariants we defined above, but it's still not <em>generic</em>...let's fix that.</p>
<h2 id="next-steps-a-generic-event-feed">Next Steps: A Generic Event Feed</h2>
<p><img src="https://github.com/MariaLetta/free-gophers-pack/blob/master/illustrations/png/15.png?raw=true" alt="image" /></p>
<p>Although Go itself doesn't have built in generic functions, we can still define functions that take in the empty interface <code>interface{}</code>, and use the reflect package from the standard library to perform operations based on the exact type and value passed in. Let's see what we can do by defining a fully generic Feed.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Feed </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    lock sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Mutex
</span><span>    sending </span><span style="color:#ff7733;">chan struct</span><span>{}
</span><span>    sendCases []reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">Feed</span><span>) </span><span style="color:#ffb454;">Subscribe</span><span>(</span><span style="color:#f29718;">ch </span><span style="color:#ff7733;">interface</span><span>{}) (</span><span style="color:#ff7733;">Subscription</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">error</span><span>) {
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    </span><span style="color:#ff7733;">defer </span><span>f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>    val </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ValueOf</span><span>(ch)
</span><span>    chanTyp </span><span style="color:#f29668;">:= </span><span>val</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Type</span><span>()
</span><span>    </span><span style="color:#ff7733;">if </span><span>chanTyp</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Kind</span><span>() </span><span style="color:#f29668;">!= </span><span>reflect</span><span style="color:#f29668;">.</span><span>Chan {
</span><span>        </span><span style="color:#ff7733;">return </span><span style="color:#f29718;">nil</span><span style="color:#bfbab0cc;">, </span><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;wanted channel type as input, received </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>chanTyp)
</span><span>    }
</span><span>    cs </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span>SelectCase{Dir</span><span style="color:#bfbab0cc;">: </span><span>reflect</span><span style="color:#f29668;">.</span><span>SelectSend</span><span style="color:#bfbab0cc;">, </span><span>Chan</span><span style="color:#bfbab0cc;">: </span><span>val}
</span><span>    f</span><span style="color:#f29668;">.</span><span>sendCases </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(f</span><span style="color:#f29668;">.</span><span>sendCases</span><span style="color:#bfbab0cc;">, </span><span>cs)
</span><span>    </span><span style="color:#ff7733;">return </span><span style="color:#f29668;">&amp;</span><span>sub{
</span><span>        feed</span><span style="color:#bfbab0cc;">: </span><span>f</span><span style="color:#bfbab0cc;">,
</span><span>        channelIndex</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>sendCases)</span><span style="color:#f29668;">-</span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">,
</span><span>        channel</span><span style="color:#bfbab0cc;">: </span><span>val</span><span style="color:#bfbab0cc;">,
</span><span>        err</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">error</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now, we can accept any generic channel, and instead of keeping track of <code>[]chan bool</code>, we now keep track of <code>[]reflect.SelectCase</code>, what does this mean? From <a href="https://godoc.org/reflect#SelectCase">Godocs</a>, we see there it's a useful wrapper in the standard library for keeping track of a channel and whether or not it is send-only or receive-only, which will be helpful later.</p>
<p>In our <code>Send</code> function, we can now accept <em>any</em> value by attempting to send over the tracked channels:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">Feed</span><span>) </span><span style="color:#ffb454;">Send</span><span>(</span><span style="color:#f29718;">value </span><span style="color:#ff7733;">interface</span><span>{}) {
</span><span>    rvalue </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ValueOf</span><span>(value)
</span><span>    </span><span style="color:#f29668;">&lt;-</span><span>f</span><span style="color:#f29668;">.</span><span>sending
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    </span><span style="color:#ff7733;">for </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span>cs </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>f</span><span style="color:#f29668;">.</span><span>sendCases {
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Set the sent value on all channels.
</span><span>        cs</span><span style="color:#f29668;">.</span><span>Send </span><span style="color:#f29668;">= </span><span>rvalue
</span><span>        cs</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TrySend</span><span>(rvalue)
</span><span>    }
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>    f</span><span style="color:#f29668;">.</span><span>sending </span><span style="color:#f29668;">&lt;- </span><span style="color:#ff7733;">struct</span><span>{}{}
</span><span>}
</span></code></pre>
<p>We use <code>sending chan struct{}</code> as a way to protect the Send function and make it fully thread safe, as there could be many calls to Send occurring at the same time, we want to ensure they can only happen sequentially.</p>
<h2 id="a-critical-problem-with-our-approach">A Critical Problem With Our Approach</h2>
<p>It seems like now we met most of our invariants, but what's critically wrong from the code above? It seems simple enough, no? Consider the first section of this blog post where we talked about the merits of unbuffered vs. buffered channels as well as typical gotchas regarding them. Well, when we attempt to subscribe any generic channel into our <code>Feed</code> data structure using the code above, we have <strong>no way of determinining whether the channel is buffered or not</strong>. That is, we cannot determine if some operations will block on send while others will not, and that will lead to chaos if we try to use our naïve approach at runtime. Plus, keep in mind we deliver data to listeners by doing a simple for loop over a list of registered channels and performing a send operation, but what if we have the following registered listeners:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span>[
</span><span>    </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">2</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">1</span><span>)
</span><span>]
</span></code></pre>
<p>Any attempt to do:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span>cs</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TrySend</span><span>(rvalue)
</span></code></pre>
<p>...will succeed on the first channel's send, but <strong>block</strong> the thread on the second if there is no active listener, and remember one of our invariants was that the sender should <strong>not</strong> care about who's listening or their status, but this invariably leads to a major problem.</p>
<p>Can we do better?</p>
<h2 id="towards-a-smarter-non-blocking-approach">Towards a Smarter, Non-Blocking Approach</h2>
<p>Instead of trying once and possibly failing, we <em>must</em> keep trying to send the data over every listener until all of them either:</p>
<ul>
<li>(a) succeed, or...</li>
<li>(b) some of them unsubscribe themselves from the feed</li>
</ul>
<p>The <code>TrySend</code> function can actually fail and returns a bool value of <code>false</code> if the channel we are sending to has a full buffer, in which case our logic above does not work. Instead of keeping a single slice of channels we should send over, we can keep two slices: one for channels we have yet to attempt to send, and another for channels we finished sending over. Let's call the former <code>pendingProcessing</code> and the other <code>inProgress</code>.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Feed </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    lock sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Mutex
</span><span>    pendingProcessing []reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase
</span><span>    inProgress []reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase
</span><span>}
</span></code></pre>
<p>We should have a while loop which proceeds until all inProgress cases have been marked as done, and if some of the receiving channels are blocked, we should wait in each iteration of the loop until they unblock before attempting to send again. Here's a bit of pseudocode of how this could work:</p>
<pre data-lang="python" style="background-color:#0f1419;color:#bfbab0;" class="language-python "><code class="language-python" data-lang="python"><span>processing </span><span style="color:#f29668;">= </span><span>feed</span><span style="color:#f29668;">.</span><span>in_progress
</span><span style="color:#ff7733;">while</span><span>:
</span><span>    </span><span style="color:#ff7733;">for </span><span>case </span><span style="color:#ff7733;">in </span><span>processing:
</span><span>        </span><span style="font-style:italic;color:#5c6773;"># If the channel is blocking, this will fail!
</span><span>        </span><span style="color:#ff7733;">if </span><span>case</span><span style="color:#f29668;">.</span><span>try_send:
</span><span>            cases </span><span style="color:#f29668;">= </span><span>cases</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">mark_succeded</span><span>(case)
</span><span>    </span><span style="color:#ff7733;">if </span><span style="color:#f07178;">len</span><span>(cases) </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0</span><span>:
</span><span>        </span><span style="color:#ff7733;">break
</span><span>    </span><span style="font-style:italic;color:#5c6773;"># For cases that failed and were not marked as succeeded, we pseudo-randomly
</span><span>    </span><span style="font-style:italic;color:#5c6773;"># pick one of them, block with a select statement, and wait for it to unblock
</span><span>    </span><span style="font-style:italic;color:#5c6773;"># and receive our data. Then, we mark it as succeeded.
</span><span>    chosen </span><span style="color:#f29668;">= </span><span style="color:#ffb454;">wait_for_unblocked_and_send</span><span>(cases)
</span><span>    cases </span><span style="color:#f29668;">= </span><span>cases</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">mark_succeded</span><span>(chosen)
</span></code></pre>
<p><img src="https://raw.githubusercontent.com/MariaLetta/free-gophers-pack/master/illustrations/png/19.png" alt="image" /></p>
<p>With the logic above, eventually every single in progress case will complete and will get data sent over its channel. Next, we need a function which will deactivate cases from the <code>inProgress</code> slice as we successfully send over them, the <code>mark_succeeded</code> function from our pseudocode above.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// removes an channel at index i efficiently as order does not
</span><span style="font-style:italic;color:#5c6773;">// matter for listeners we keep track of.
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">deactivate</span><span>(</span><span style="color:#f29718;">cs </span><span>[]reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">index </span><span style="font-style:italic;color:#39bae6;">int</span><span>) []reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase </span><span>{
</span><span>    last </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">len</span><span>(cs) </span><span style="color:#f29668;">- </span><span style="color:#f29718;">1
</span><span>    cs[index]</span><span style="color:#bfbab0cc;">, </span><span>cs[last] </span><span style="color:#f29668;">= </span><span>cs[last]</span><span style="color:#bfbab0cc;">, </span><span>cs[index]
</span><span>    </span><span style="color:#ff7733;">return </span><span>cs[</span><span style="color:#bfbab0cc;">:</span><span>last]
</span><span>}
</span></code></pre>
<p>We name the function <code>deactivate</code> as it basically removes an item at an index from the slice of cases we are attempting to send over. Once the send succeeds, we <code>deactivate</code> the case.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">f </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">Feed</span><span>) </span><span style="color:#ffb454;">Send</span><span>(</span><span style="color:#f29718;">value </span><span style="color:#ff7733;">interface</span><span>{}) (</span><span style="color:#f29718;">nsent </span><span style="font-style:italic;color:#39bae6;">int</span><span>) {
</span><span>    rvalue </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ValueOf</span><span>(value)
</span><span>    </span><span style="color:#f29668;">&lt;-</span><span>f</span><span style="color:#f29668;">.</span><span>sending
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Add new cases from the pendingProcessing slice after taking the send lock.
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Lock</span><span>()
</span><span>    f</span><span style="color:#f29668;">.</span><span>inProgress </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(f</span><span style="color:#f29668;">.</span><span>inProgress</span><span style="color:#bfbab0cc;">, </span><span>f</span><span style="color:#f29668;">.</span><span>pendingProcessing</span><span style="color:#f29668;">...</span><span>)
</span><span>    f</span><span style="color:#f29668;">.</span><span>pendingProcessing </span><span style="color:#f29668;">= </span><span style="color:#f29718;">nil
</span><span>    f</span><span style="color:#f29668;">.</span><span>lock</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unlock</span><span>()
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Set the Send value on all channels.
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span>firstSubSendCase</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>inProgress)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        f</span><span style="color:#f29668;">.</span><span>inProgress[i]</span><span style="color:#f29668;">.</span><span>Send </span><span style="color:#f29668;">= </span><span>rvalue
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Send until all channels have been chosen. &#39;cases&#39; tracks a prefix
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// of inProgress. When a send succeeds, the corresponding case moves to the end of
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// &#39;cases&#39; and it shrinks by one element.
</span><span>    cases </span><span style="color:#f29668;">:= </span><span>f</span><span style="color:#f29668;">.</span><span>inProgress
</span><span>    </span><span style="color:#ff7733;">for </span><span>{
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Try sending without blocking before adding to the select set.
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// This should usually succeed if subscribers are fast enough and have free
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// buffer space.
</span><span>        </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(cases)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>            </span><span style="color:#ff7733;">if </span><span>cases[i]</span><span style="color:#f29668;">.</span><span>Chan</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TrySend</span><span>(rvalue) {
</span><span>                nsent</span><span style="color:#f29668;">++
</span><span>                cases </span><span style="color:#f29668;">= </span><span>cases</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">deactivate</span><span>(i)
</span><span>                i</span><span style="color:#f29668;">--
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#ff7733;">if </span><span style="color:#f07178;">len</span><span>(cases) </span><span style="color:#f29668;">== </span><span style="color:#f29718;">0 </span><span>{
</span><span>            </span><span style="color:#ff7733;">break
</span><span>        }
</span><span>        </span><span style="font-style:italic;color:#5c6773;">// Select on all the receivers, waiting for them to unblock.
</span><span>        chosen</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span style="font-style:italic;color:#39bae6;">_ </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Select</span><span>(cases)
</span><span>        cases </span><span style="color:#f29668;">= </span><span>cases</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">deactivate</span><span>(chosen)
</span><span>        nsent</span><span style="color:#f29668;">++
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Forget about the sent value.
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span style="color:#f07178;">len</span><span>(f</span><span style="color:#f29668;">.</span><span>inProgress)</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        f</span><span style="color:#f29668;">.</span><span>inProgress[i]</span><span style="color:#f29668;">.</span><span>Send </span><span style="color:#f29668;">= </span><span>reflect</span><span style="color:#f29668;">.</span><span>Value{}
</span><span>    }
</span><span>    f</span><span style="color:#f29668;">.</span><span>sending </span><span style="color:#f29668;">&lt;- </span><span style="color:#ff7733;">struct</span><span>{}{}
</span><span>    </span><span style="color:#ff7733;">return </span><span>nsent
</span><span>}
</span></code></pre>
<p>What's going on over here? Well, from the pseudocode from earlier, if <code>TrySend</code> fails, we'll go into the latter part of our for loop, which will use <code>reflect.Select(cases)</code>, which pretty much simulates a real, blocking <code>select</code> block in Go!</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">select </span><span>{
</span><span style="color:#ff7733;">case </span><span style="color:#ffb454;">waitTillUnblocked</span><span>(someChan)</span><span style="color:#bfbab0cc;">:
</span><span>    someChan </span><span style="color:#f29668;">&lt;- </span><span>data
</span><span>}
</span></code></pre>
<p>This will pseudorandomly pick one of the channels which did not succeed, block the thread until the channel is unblocked, and then send the data over it. With this, we have all the pieces needed to test this out and make sure it fits our invariants. If we try running</p>
<h2 id="testing-benchmarks">Testing &amp; Benchmarks</h2>
<p>How does one even begin to test something like this? With channels of course! Given we have a lot of concurrency, we will have to be careful with our test setup to avoid any deadlocks or goroutine leaks, all while ensuring we properly test the behavior of our functions. Let's try to setup a test to ensure the one-to-many functionality invariant of our library is met.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">TestFeed_OneToMany</span><span>(</span><span style="color:#f29718;">t </span><span style="color:#f29668;">*</span><span>testing</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">T</span><span>) {
</span><span>    feed </span><span style="color:#f29668;">:= &amp;</span><span>Feed{
</span><span>        pendingProcessing</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>([]reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>        inProgress</span><span style="color:#bfbab0cc;">:        </span><span style="color:#f07178;">make</span><span>([]reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">var </span><span>done</span><span style="color:#bfbab0cc;">, </span><span>subscribed sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">WaitGroup
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We create a wait group for subscribing and a wait group for completing
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// the receipt of the value.
</span><span>    numRoutines </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">10
</span><span>    done</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Add</span><span>(numRoutines)
</span><span>    subscribed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Add</span><span>(numRoutines)
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span>numRoutines</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        </span><span style="color:#ff7733;">go func</span><span>() {
</span><span>            </span><span style="color:#ff7733;">defer </span><span>done</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Done</span><span>()
</span><span>            ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">bool</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)
</span><span>            sub</span><span style="color:#bfbab0cc;">, </span><span>err </span><span style="color:#f29668;">:= </span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Subscribe</span><span>(ch)
</span><span>            </span><span style="color:#ff7733;">defer </span><span>sub</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Unsubscribe</span><span>()
</span><span>            </span><span style="color:#ff7733;">if </span><span>err </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">nil </span><span>{
</span><span>                t</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Fatal</span><span>(err)
</span><span>            }
</span><span>            </span><span style="font-style:italic;color:#5c6773;">// We notify the wait group we finished subscribing.
</span><span>            subscribed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Done</span><span>()
</span><span>            </span><span style="color:#ff7733;">select </span><span>{
</span><span>            </span><span style="color:#ff7733;">case </span><span>val </span><span style="color:#f29668;">:= &lt;-</span><span>ch</span><span style="color:#bfbab0cc;">:
</span><span>                t</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Logf</span><span>(</span><span style="color:#c2d94c;">&quot;Received value in listener </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>i</span><span style="color:#bfbab0cc;">, </span><span>val)
</span><span>                </span><span style="color:#ff7733;">return
</span><span>            </span><span style="color:#ff7733;">case </span><span>err </span><span style="color:#f29668;">:= &lt;-</span><span>sub</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Err</span><span>()</span><span style="color:#bfbab0cc;">:
</span><span>                t</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;Received error in listener </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>i</span><span style="color:#bfbab0cc;">, </span><span>err)
</span><span>                </span><span style="color:#ff7733;">return
</span><span>            }
</span><span>        }()
</span><span>    }
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We wait for all subscriptions to be completed before we send anything out.
</span><span>    subscribed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Wait</span><span>()
</span><span>    </span><span style="color:#ff7733;">if </span><span>nsent </span><span style="color:#f29668;">:= </span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Send</span><span>(</span><span style="color:#f29718;">true</span><span>)</span><span style="color:#bfbab0cc;">; </span><span>nsent </span><span style="color:#f29668;">!= </span><span>numRoutines {
</span><span>        t</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;First send delivered </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;"> times, wanted </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>nsent</span><span style="color:#bfbab0cc;">, </span><span>numRoutines)
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We wait for the values to be received before finishing the test.
</span><span>    done</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Wait</span><span>()
</span><span>}
</span></code></pre>
<p>In the example above, we simply setup 10 subscribers which are waiting to receive
information on a subscribed channel they initialized. We create two wait groups so we can
wait for the subscriptions to be registered and for the subscribers to receive the values. We simply do a <code>feed.Send</code> and finally the number of sends matches the number of goroutines - simple enough!</p>
<p>Let's see how a benchmark would work here.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span style="color:#ffb454;">BenchmarkFeed_Send</span><span>(</span><span style="color:#f29718;">b </span><span style="color:#f29668;">*</span><span>testing</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">B</span><span>) {
</span><span>    feed </span><span style="color:#f29668;">:= &amp;</span><span>Feed{
</span><span>        pendingProcessing</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>([]reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>        inProgress</span><span style="color:#bfbab0cc;">:        </span><span style="color:#f07178;">make</span><span>([]reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">SelectCase</span><span style="color:#bfbab0cc;">, </span><span style="color:#f29718;">0</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>    }
</span><span>    numRoutines </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">1000
</span><span>
</span><span>    </span><span style="color:#ff7733;">var </span><span>wg sync</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">WaitGroup
</span><span>    wg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Add</span><span>(numRoutines)
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span>numRoutines</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        ch </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">int</span><span style="color:#bfbab0cc;">, </span><span>numRoutines)
</span><span>        feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Subscribe</span><span>(ch)
</span><span>        </span><span style="color:#ff7733;">go func</span><span>(</span><span style="color:#f29718;">cc </span><span style="color:#ff7733;">chan </span><span style="font-style:italic;color:#39bae6;">int</span><span>) {
</span><span>            </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span>b</span><span style="color:#f29668;">.</span><span>N</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>                </span><span style="color:#f29668;">&lt;-</span><span>cc
</span><span>            }
</span><span>            done</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Done</span><span>()
</span><span>        }(ch)
</span><span>    }
</span><span>
</span><span>    b</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ResetTimer</span><span>()
</span><span>    </span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&lt; </span><span>b</span><span style="color:#f29668;">.</span><span>N</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">++ </span><span>{
</span><span>        </span><span style="color:#ff7733;">if </span><span>feed</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Send</span><span>(i) </span><span style="color:#f29668;">!= </span><span>numRoutines {
</span><span>            b</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Fatal</span><span>(</span><span style="color:#c2d94c;">&quot;Incorrect number of sends&quot;</span><span>)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    b</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">StopTimer</span><span>()
</span><span>    done</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Wait</span><span>()
</span><span>}
</span></code></pre>
<p>The results only make 1 allocation per operation as we initialize a channel, but we do see quite a few ns/operation of running our <code>Send</code> function:</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>$ go test -bench=. -benchmem
</span><span>goos: darwin
</span><span>goarch: amd64
</span><span>BenchmarkFeed_Send-4   	   10000	    252560 ns/op	      13 B/op	       1 allocs/op
</span><span>PASS
</span></code></pre>
<p>We can wrap this up! So we ended up doing a whirlwind tour of buffered vs. unbuffered channels, learned about goroutines and deadlock, and finally ended up recreating the event library used by the <a href="https://github.com/ethereum/go-ethereum/blob/master/event/feed.go">go-ethereum</a> and the <a href="https://github.com/prysmaticlabs/prysm/blob/master/shared/event/feed.go">Prysm</a> project, hopefully making concurrency a bit less intimidating, one step at a time :). The finalized event feed library from the prior section looks very similar to the Go-Ethereum <code>Feed</code> implementation so feel free to use it as a reference and try to run it yourself!</p>
<h2 id="other-recommended-readings">Other Recommended Readings</h2>
<ul>
<li><a href="https://robertbasic.com/blog/buffered-vs-unbuffered-channels-in-golang/">Buffered Channels in Go</a></li>
<li><a href="https://medium.com/rungo/anatomy-of-channels-in-go-concurrency-in-go-1ec336086adb">Anatomy of a Go Channel</a></li>
</ul>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">More posts</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://rauljordan.com/key-takeaways-from-a-harvard-education/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">10 Key Takeaways from a Harvard Education</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://rauljordan.com/building-a-service-registry-in-go/">
                            <span class="button__text">Building a Service Registry in Go</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2023
 Raul Jordan</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
