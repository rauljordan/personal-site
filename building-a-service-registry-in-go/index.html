<!DOCTYPE html>
<html lang="en">

<head>
    <title>rauljordan::blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://rauljordan.com/style.css">
    <link rel="stylesheet" href="https://rauljordan.com/color/orange.css">

        <link rel="stylesheet" href="https://rauljordan.com/color/background_pink.css">
    
    <link rel="stylesheet" href="https://rauljordan.com/font-hack-subset.css">

        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://rauljordan.com/rss.xml">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@rauljordaneth">
    <meta name="twitter:creator" content="@rauljordaneth">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://rauljordan.com" />
    <meta property="og:site_name" content="rauljordan::blog" />

    
<meta property="og:title" content="Building a Service Registry in Go" />
<meta property="og:locale" content="en_US" />
<meta property="og:description" content="" />
<meta property="og:site_name" content="rauljordan::blog" />
<meta property="og:image" content="" />
<meta property="og:type" content="article" />

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:title" content="Building a Service Registry in Go" />
<meta property="twitter:image" content="" />
<meta property="twitter:description" content="" />
<meta name="twitter:site" content="@rauljordaneth" />
<meta name="twitter:creator" content="@rauljordaneth" />

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-53062950-12"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-53062950-12');
    </script>
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://rauljordan.com" style="text-decoration: none;">
                    <div class="logo">
                      
                            rauljordan::blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://rauljordan.com/tags">tags</a></li>
            
                <li><a href="https://rauljordan.com/archive">archive</a></li>
            
                <li><a href="https://rauljordan.com/about-me">about me</a></li>
            
                <li><a href="https://twitter.com/rauljordaneth" target="_blank" rel="noopener noreferrer">twitter</a></li>
            
                <li><a href="https://github.com/rauljordan" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://rauljordan.com/building-a-service-registry-in-go/">Building a Service Registry in Go</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2020-03-10
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://rauljordan.com/tags/golang/">#golang</a></span>
    

        
        <div class="post-content">
            <pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) </span><span style="color:#ffb454;">RegisterService</span><span>(
</span><span>  </span><span style="color:#f29718;">service </span><span style="color:#ff7733;">Service</span><span style="color:#bfbab0cc;">,
</span><span>) </span><span style="font-style:italic;color:#39bae6;">error </span><span>{
</span><span>	kind </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TypeOf</span><span>(service)
</span><span>	</span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span>exists </span><span style="color:#f29668;">:= </span><span>s</span><span style="color:#f29668;">.</span><span>services[kind]</span><span style="color:#bfbab0cc;">; </span><span>exists {
</span><span>		</span><span style="color:#ff7733;">return </span><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;exists: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>kind)
</span><span>	}
</span><span>	s</span><span style="color:#f29668;">.</span><span>services[kind] </span><span style="color:#f29668;">= </span><span>service
</span><span>	s</span><span style="color:#f29668;">.</span><span>serviceTypes </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(s</span><span style="color:#f29668;">.</span><span>serviceTypes</span><span style="color:#bfbab0cc;">, </span><span>kind)
</span><span>	</span><span style="color:#ff7733;">return </span><span style="color:#f29718;">nil
</span><span>}
</span></code></pre>
<p>Thinking of building an application in Go that has multiple running parts? Say you have some server that needs to do a bunch of different things while it runs, such as perform some backround jobs, update caches, handle several requests, expose a REST API, perform outbound requests to other APIs, all without blocking the main thread - what do you do? Typically, this is a good task for creating a microservices architecture where you have multiple applications talking to each other over some network service mesh, each containerized in some nice docker environment, orchestrated through something like Kubernetes or docker-compose.</p>
<span id="continue-reading"></span>
<p><img src="https://golang.org/doc/gopher/fiveyears.jpg" alt="image" /></p>
<p>However, sometimes you just want a straightforward application that can do it all! A good example of this is a blockchain node, such as a Bitcoin or Ethereum node, which needs to do a bunch of things while it runs including:</p>
<ul>
<li>Syncing the blockchain</li>
<li>Exposing an RPC endpoint</li>
<li>Mining blocks, rewarding miners accordingly</li>
<li>Listening for p2p connections and handling the lifecycles of peers</li>
<li>Maintaining an open database connection to some persistent key-value store such as Level-DB</li>
</ul>
<p>Some of the items above depend on each other, and they should all run when I start a single process for the node. How do we implement something like this in Go? This is a perfect use case for dependency injection. In this blog post, we're going to look at a simple pattern to get this done.</p>
<p>First, our runtime is basically a series of <strong>services</strong>, each doing a bunch of things, asking for or sending data between each other, and possibly having errors or critical failures that we should easily be aware of from a bird's eye view. We want to ideally declare the services that should run upon starting the process, and should have a way of gracefully stopping them if the service dies. We can then define an interface called <code>Service</code> which lets us</p>
<ol>
<li>Start the process</li>
<li>Stop the process</li>
<li>Check the process' current status</li>
</ol>
<p>Anything that meets the criteria above is a service under our definition! We'll see why this is helpful below.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Service </span><span style="color:#ff7733;">interface </span><span>{
</span><span>	</span><span style="font-style:italic;color:#5c6773;">// Start spawns the main process done by the service.
</span><span>	</span><span style="color:#ffb454;">Start</span><span>()
</span><span>	</span><span style="font-style:italic;color:#5c6773;">// Stop terminates all processes belonging to the service,
</span><span>	</span><span style="font-style:italic;color:#5c6773;">// blocking until they are all terminated.
</span><span>	</span><span style="color:#ffb454;">Stop</span><span>() </span><span style="font-style:italic;color:#39bae6;">error
</span><span>	</span><span style="font-style:italic;color:#5c6773;">// Returns error if the service is not considered healthy.
</span><span>	</span><span style="color:#ffb454;">Status</span><span>() </span><span style="font-style:italic;color:#39bae6;">error
</span><span>}
</span></code></pre>
<p>Next up, we're gonna define an actual struct that will keep track of services by their particular type. We keep around a map of services by their type, but we <em>also</em> keep around an <em>ordered</em> list of these types, given maps in Go do not have a set order. It's important for us to define an order of services, as services can often depend on others that should be initialized <strong>first</strong>.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// ServiceRegistry provides a useful pattern for managing services.
</span><span style="font-style:italic;color:#5c6773;">// It allows for ease of dependency management and ensures services
</span><span style="font-style:italic;color:#5c6773;">// dependent on others use the same references in memory.
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">ServiceRegistry </span><span style="color:#ff7733;">struct </span><span>{
</span><span>	services     </span><span style="color:#ff7733;">map</span><span>[reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Type</span><span>]</span><span style="color:#ff7733;">Service </span><span style="font-style:italic;color:#5c6773;">// map of types to services.
</span><span>	serviceTypes []reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Type           </span><span style="font-style:italic;color:#5c6773;">// keep an ordered slice of registered service types.
</span><span>}
</span><span>
</span><span style="font-style:italic;color:#5c6773;">// NewServiceRegistry starts a registry instance for convenience
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">NewServiceRegistry</span><span>() </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry </span><span>{
</span><span>	</span><span style="color:#ff7733;">return </span><span style="color:#f29668;">&amp;</span><span>ServiceRegistry{
</span><span>		services</span><span style="color:#bfbab0cc;">: </span><span style="color:#f07178;">make</span><span>(</span><span style="color:#ff7733;">map</span><span>[reflect</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Type</span><span>]</span><span style="color:#ff7733;">Service</span><span>)</span><span style="color:#bfbab0cc;">,
</span><span>	}
</span><span>}
</span></code></pre>
<p>Next up, we want to be able to register services into our registry in a particular order. If a service does not exist in the registry, we add it to the map and also to our ordered list of registered service types.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// RegisterService appends a service constructor function to the service
</span><span style="font-style:italic;color:#5c6773;">// registry.
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) </span><span style="color:#ffb454;">RegisterService</span><span>(</span><span style="color:#f29718;">service </span><span style="color:#ff7733;">Service</span><span>) </span><span style="font-style:italic;color:#39bae6;">error </span><span>{
</span><span>	kind </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TypeOf</span><span>(service)
</span><span>	</span><span style="color:#ff7733;">if </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span>exists </span><span style="color:#f29668;">:= </span><span>s</span><span style="color:#f29668;">.</span><span>services[kind]</span><span style="color:#bfbab0cc;">; </span><span>exists {
</span><span>		</span><span style="color:#ff7733;">return </span><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;service already exists: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>kind)
</span><span>	}
</span><span>	s</span><span style="color:#f29668;">.</span><span>services[kind] </span><span style="color:#f29668;">= </span><span>service
</span><span>	s</span><span style="color:#f29668;">.</span><span>serviceTypes </span><span style="color:#f29668;">= </span><span style="color:#f07178;">append</span><span>(s</span><span style="color:#f29668;">.</span><span>serviceTypes</span><span style="color:#bfbab0cc;">, </span><span>kind)
</span><span>	</span><span style="color:#ff7733;">return </span><span style="color:#f29718;">nil
</span><span>}
</span></code></pre>
<p>Next up, we want to be able to actually <strong>start</strong> all our services in the order specified at the time of registration. Let's take a look:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// StartAll initialized each service in order of registration.
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) </span><span style="color:#ffb454;">StartAll</span><span>() {
</span><span>	log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Infof</span><span>(</span><span style="color:#c2d94c;">&quot;Starting </span><span style="color:#f29718;">%d</span><span style="color:#c2d94c;"> services: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span style="color:#f07178;">len</span><span>(s</span><span style="color:#f29668;">.</span><span>serviceTypes)</span><span style="color:#bfbab0cc;">, </span><span>s</span><span style="color:#f29668;">.</span><span>serviceTypes)
</span><span>	</span><span style="color:#ff7733;">for </span><span style="font-style:italic;color:#39bae6;">_</span><span style="color:#bfbab0cc;">, </span><span>kind </span><span style="color:#f29668;">:= </span><span style="color:#ff7733;">range </span><span>s</span><span style="color:#f29668;">.</span><span>serviceTypes {
</span><span>		log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Debugf</span><span>(</span><span style="color:#c2d94c;">&quot;Starting service type </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>kind)
</span><span>		</span><span style="color:#ff7733;">go </span><span>s</span><span style="color:#f29668;">.</span><span>services[kind]</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Start</span><span>()
</span><span>	}
</span><span>}
</span></code></pre>
<p>We start each service in a <code>goroutine</code> so it does not block the main thread according to its specified <code>.Start()</code> method.
When we wish to <strong>gracefully stop</strong> everything, and we call the <code>.Stop()</code> function for each service in <strong>reverse order</strong> of registration, checking for errors along the way.</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// StopAll ends every service in reverse order of registration, logging a
</span><span style="font-style:italic;color:#5c6773;">// panic if any of them fail to stop.
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) </span><span style="color:#ffb454;">StopAll</span><span>() {
</span><span>	</span><span style="color:#ff7733;">for </span><span>i </span><span style="color:#f29668;">:= </span><span style="color:#f07178;">len</span><span>(s</span><span style="color:#f29668;">.</span><span>serviceTypes) </span><span style="color:#f29668;">- </span><span style="color:#f29718;">1</span><span style="color:#bfbab0cc;">; </span><span>i </span><span style="color:#f29668;">&gt;= </span><span style="color:#f29718;">0</span><span style="color:#bfbab0cc;">; </span><span>i</span><span style="color:#f29668;">-- </span><span>{
</span><span>		kind </span><span style="color:#f29668;">:= </span><span>s</span><span style="color:#f29668;">.</span><span>serviceTypes[i]
</span><span>		service </span><span style="color:#f29668;">:= </span><span>s</span><span style="color:#f29668;">.</span><span>services[kind]
</span><span>		</span><span style="color:#ff7733;">if </span><span>err </span><span style="color:#f29668;">:= </span><span>service</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Stop</span><span>()</span><span style="color:#bfbab0cc;">; </span><span>err </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">nil </span><span>{
</span><span>			log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Panicf</span><span>(</span><span style="color:#c2d94c;">&quot;Could not stop the following service: </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">, </span><span style="color:#f29718;">%v</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>kind</span><span style="color:#bfbab0cc;">, </span><span>err)
</span><span>		}
</span><span>	}
</span><span>}
</span></code></pre>
<h3 id="so-how-do-we-use-this">So How Do We Use This?</h3>
<p>Now we have a cool way to do run multiple services from within a single application, how do we put it to use? Let's talk about a simple architecture!</p>
<pre style="background-color:#0f1419;color:#bfbab0;"><code><span>mygoproject/
</span><span>  p2p/
</span><span>    service.go
</span><span>  api/
</span><span>    service.go
</span><span>  db/
</span><span>    service.go
</span><span>  numbercrunching/
</span><span>    service.go 
</span></code></pre>
<p>We register and start each service in the required order:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">package </span><span>main
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    registry </span><span style="color:#f29668;">:= </span><span style="color:#ffb454;">NewServiceRegistry</span><span>()
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Register our database first.
</span><span>    db </span><span style="color:#f29668;">:= </span><span>database</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeDB</span><span>()
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(db)
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We then start up our p2p server.
</span><span>    p2pServer </span><span style="color:#f29668;">:= </span><span>p2p</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeP2P</span><span>()
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(p2pServer)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We then start up our API.
</span><span>    apiServer </span><span style="color:#f29668;">:= </span><span>api</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeAPI</span><span>()
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(apiServer)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We then start up some number crunching service.
</span><span>    miscServer </span><span style="color:#f29668;">:= </span><span>misc</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeNumberCrunching</span><span>()
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(miscServer)
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Rev it up!
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">StartAll</span><span>()
</span><span>}
</span></code></pre>
<p>Does the code above do something...? What if my API server depends on the DB, what if my number cruncher depends on my API...? <strong>How can we we implement dependencies between services???</strong></p>
<h3 id="enter-dependency-injection">Enter Dependency Injection</h3>
<p>There's a reason we declared and registered each service in the order specified. That is, some services depend on others, and we want to keep the whole dependency graph quite simple. An important programming paradigm is the idea of <strong>separation of concerns</strong>, which means each module in a program should be concerned with its specific logic and shouldn't be tasked to do things outside of its logical scope. That is, you shouldn't expect your API server to also deal with the internals of handling the db connection, or with dialing other servers via a p2p peer manager. Everything should be self-contained, easy to reason about, and easier to test. </p>
<p><img src="https://miro.medium.com/max/5000/1*Dqi3QdCy-LbdtS69-rLZcg.png" alt="image" /></p>
<p>A big part of separation of concerns in our toy example above is that each service shouldn't care about how to get access to other services. It should be provided its dependencies at the time of initialization. That is, if I'm the API server, I should just know I <strong>have</strong> access to the db and the p2p services, <em>I shouldn't need to worry about how to request them fetch them from somewhere far away</em>.</p>
<p>This concept of explicitly defining the dependencies and <em>injecting</em> them into services that need them is known as <strong>dependency injection</strong>, a fancy term that now makes more sense when you look at our code above. If you look at our API server code, it probably looks quite straighforward if we follow the service pattern above:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">package </span><span>api
</span><span>
</span><span style="color:#ff7733;">type </span><span style="color:#59c2ff;">Server </span><span style="color:#ff7733;">struct </span><span>{
</span><span>    db </span><span style="color:#f29668;">*</span><span>database</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Database
</span><span>    p2pServer </span><span style="color:#f29668;">*</span><span>p2p</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Server
</span><span>}
</span></code></pre>
<p>The API Server doesn't need to worry about how to access the db or p2p services, as it already has them injected into it upon initialization! Pretty cool...but our service registry code doesn't allow for this injection just yet. Let's see how we can do it.</p>
<blockquote>
<p>Dependency injection is awesome</p>
</blockquote>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="font-style:italic;color:#5c6773;">// FetchService takes in a struct pointer and sets the value of that pointer
</span><span style="font-style:italic;color:#5c6773;">// to a service currently stored in the service registry. This ensures the input argument is
</span><span style="font-style:italic;color:#5c6773;">// set to the right pointer that refers to the originally registered service.
</span><span style="color:#ff7733;">func </span><span>(</span><span style="color:#f29718;">s </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) </span><span style="color:#ffb454;">FetchService</span><span>(</span><span style="color:#f29718;">service </span><span style="color:#ff7733;">interface</span><span>{}) </span><span style="font-style:italic;color:#39bae6;">error </span><span>{
</span><span>	</span><span style="color:#ff7733;">if </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">TypeOf</span><span>(service)</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Kind</span><span>() </span><span style="color:#f29668;">!= </span><span>reflect</span><span style="color:#f29668;">.</span><span>Ptr {
</span><span>		</span><span style="color:#ff7733;">return </span><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;input must be of pointer type, received value type instead: </span><span style="color:#f29718;">%T</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>service)
</span><span>	}
</span><span>	element </span><span style="color:#f29668;">:= </span><span>reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ValueOf</span><span>(service)</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Elem</span><span>()
</span><span>	</span><span style="color:#ff7733;">if </span><span>running</span><span style="color:#bfbab0cc;">, </span><span>ok </span><span style="color:#f29668;">:= </span><span>s</span><span style="color:#f29668;">.</span><span>services[element</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Type</span><span>()]</span><span style="color:#bfbab0cc;">; </span><span>ok {
</span><span>		element</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Set</span><span>(reflect</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">ValueOf</span><span>(running))
</span><span>		</span><span style="color:#ff7733;">return </span><span style="color:#f29718;">nil
</span><span>	}
</span><span>	</span><span style="color:#ff7733;">return </span><span>fmt</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Errorf</span><span>(</span><span style="color:#c2d94c;">&quot;unknown service: </span><span style="color:#f29718;">%T</span><span style="color:#c2d94c;">&quot;</span><span style="color:#bfbab0cc;">, </span><span>service)
</span><span>}
</span></code></pre>
<p>The fetch service function above is the key. It let's us grab the right pointer to a service we keep track of in our service registry. We can use this for dependency injection. </p>
<p>Let's refactor our code to use it:</p>
<pre data-lang="go" style="background-color:#0f1419;color:#bfbab0;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#ff7733;">package </span><span>main
</span><span>
</span><span style="color:#ff7733;">import </span><span style="color:#c2d94c;">&quot;log&quot;
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">main</span><span>() {
</span><span>    registry </span><span style="color:#f29668;">:= </span><span style="color:#ffb454;">NewServiceRegistry</span><span>()
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Register our database first.
</span><span>    db </span><span style="color:#f29668;">:= </span><span>database</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeDB</span><span>()
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(db)
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We then start up our p2p server.
</span><span>    </span><span style="color:#ffb454;">registerP2P</span><span>(registry)
</span><span>
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// We then start up our API.
</span><span>    </span><span style="color:#ffb454;">registerAPI</span><span>(registry)
</span><span>    
</span><span>    </span><span style="font-style:italic;color:#5c6773;">// Rev it up!
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">StartAll</span><span>()
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">registerP2P</span><span>(</span><span style="color:#f29718;">reg </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) {
</span><span>    </span><span style="color:#ff7733;">var </span><span>dbService </span><span style="color:#f29668;">*</span><span>database</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Service
</span><span>    </span><span style="color:#ff7733;">if </span><span>err </span><span style="color:#f29668;">:= </span><span>reg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">FetchService</span><span>(</span><span style="color:#f29668;">&amp;</span><span>dbService)</span><span style="color:#bfbab0cc;">; </span><span>err </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">nil </span><span>{
</span><span>        log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Fatal</span><span>(err)
</span><span>    }
</span><span>
</span><span>    p2pServer </span><span style="color:#f29668;">:= </span><span>p2p</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeP2P</span><span>(p2p</span><span style="color:#f29668;">.</span><span>Config{
</span><span>        database</span><span style="color:#bfbab0cc;">: </span><span>dbService</span><span style="color:#bfbab0cc;">, 
</span><span>    })
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(p2pServer)
</span><span>}
</span><span>
</span><span style="color:#ff7733;">func </span><span style="color:#ffb454;">registerAPI</span><span>(</span><span style="color:#f29718;">reg </span><span style="color:#f29668;">*</span><span style="color:#ff7733;">ServiceRegistry</span><span>) {
</span><span>    </span><span style="color:#ff7733;">var </span><span>dbService </span><span style="color:#f29668;">*</span><span>database</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Service
</span><span>    </span><span style="color:#ff7733;">if </span><span>err </span><span style="color:#f29668;">:= </span><span>reg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">FetchService</span><span>(</span><span style="color:#f29668;">&amp;</span><span>dbService)</span><span style="color:#bfbab0cc;">; </span><span>err </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">nil </span><span>{
</span><span>        log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Fatal</span><span>(err)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#ff7733;">var </span><span>p2pService </span><span style="color:#f29668;">*</span><span>p2p</span><span style="color:#f29668;">.</span><span style="color:#ff7733;">Server
</span><span>    </span><span style="color:#ff7733;">if </span><span>err </span><span style="color:#f29668;">:= </span><span>reg</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">FetchService</span><span>(</span><span style="color:#f29668;">&amp;</span><span>p2pService)</span><span style="color:#bfbab0cc;">; </span><span>err </span><span style="color:#f29668;">!= </span><span style="color:#f29718;">nil </span><span>{
</span><span>        log</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">Fatal</span><span>(err)
</span><span>    }
</span><span>
</span><span>    apiServer </span><span style="color:#f29668;">:= </span><span>api</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">InitializeAPI</span><span>(api</span><span style="color:#f29668;">.</span><span>Config{
</span><span>        database</span><span style="color:#bfbab0cc;">: </span><span>dbService</span><span style="color:#bfbab0cc;">,
</span><span>        p2p</span><span style="color:#bfbab0cc;">: </span><span>p2pService</span><span style="color:#bfbab0cc;">, 
</span><span>    })
</span><span>    registry</span><span style="color:#f29668;">.</span><span style="color:#ffb454;">RegisterService</span><span>(apiServer)
</span><span>}
</span></code></pre>
<p>There we go! We explicitly define the dependencies each service needs upon initialization, making it easy for them to maintain autonomy and separation of concerns accordingly. Next time if you have to choose between creating a complex microservice architecture, consider this simple monolith with dependency injection to save you some headaches!
We actually use this exact same pattern in my team's <code>Prysm</code> project, our implementation of the Ethereum 2.0 blockchain Go you can find <a href="https://github.com/prysmaticlabs/prysm/blob/8d3fc1ad3ecf5457bb03621f2bbf50022cfd9d65/shared/service_registry.go#L14">here</a>.</p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">More posts</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://rauljordan.com/how-to-write-an-event-feed-library/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Writing an One-to-Many Event Feed Library in Go</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://rauljordan.com/immutability-patterns-in-go/">
                            <span class="button__text">Immutability Patterns in Go</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2023
 Raul Jordan</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
